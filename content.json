{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com"},"pages":[{"title":"关于阿正","date":"2019-02-23T13:27:05.000Z","updated":"2019-02-23T15:34:31.491Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"一个努力的追梦者，起码他自己这么认为！ 中原工学院2015届学生 机械电子工程专业 目前还没毕业，实习工作于郑州中讯邮电设计院，物联网实验室硬件工程师，同时也给软件部门打打杂。 中工《校网助手》APP开发者。 单片机爱好者，32刚入门，Arduino玩的比较多，树莓派也有一两块儿。 拥有一把雅伊利吉他，会弹若干首民谣，希望以后能学会一首指弹。 愿2019自己更加努力。收获更多。"}],"posts":[{"title":"STM32_DMA再次研究总结","slug":"STM32_DMA再次研究总结","date":"2019-04-15T17:11:00.000Z","updated":"2019-04-15T17:11:48.191Z","comments":true,"path":"2019/04/16/STM32_DMA再次研究总结/","link":"","permalink":"http://yoursite.com/2019/04/16/STM32_DMA再次研究总结/","excerpt":"今天花了10分钟简单看了下STM32的DMA DMA 1234直接存储器存取(DMA)用来提供在外设和存储器之间或者存储器和存储器之间的高速数据传输。无须CPU干预，数据可以通过DMA快速地移动，这就节省了CPU的资源来做其他操作。两个DMA控制器有12个通道(DMA1有7个通道，DMA2有5个通道)，每个通道专门用来管理来自于一个或多个外设对存储器访问的请求。还有一个仲裁器来协调各个DMA请求的优先权。","text":"今天花了10分钟简单看了下STM32的DMA DMA 1234直接存储器存取(DMA)用来提供在外设和存储器之间或者存储器和存储器之间的高速数据传输。无须CPU干预，数据可以通过DMA快速地移动，这就节省了CPU的资源来做其他操作。两个DMA控制器有12个通道(DMA1有7个通道，DMA2有5个通道)，每个通道专门用来管理来自于一个或多个外设对存储器访问的请求。还有一个仲裁器来协调各个DMA请求的优先权。 DMA在我脑海里，一直是一个很神奇的东西，自己也“不敢用”（不会用）（0.0）说实话对于STM32我是一个初学者，学习它还没多久，几乎没几个月，到了公司才开始学32，但是不得不说没在公司里真的是学的非常快，因为有项目在一步一步的推进所以自己也跟着学了很多东西。今天再次打开DMA，感觉不像以前那样一头雾水了，感觉茅塞顿开！恍然大悟的感觉。今天来总结一下这一会儿我看的东西。其实，咱们平时用的最多的是：存储器和存储器间的传输外设和存储器、存储器和外设之间的传输 通道配置过程 下面是配置DMA通道x的过程(x代表通道号)： 在DMA_CPARx寄存器中设置外设寄存器的地址。发生外设数据传输请求时，这个地址将是数据传输的源或目标。 在DMA_CMARx寄存器中设置数据存储器的地址。发生外设数据传输请求时，传输的数据将从这个地址读出或写入这个地址。 在DMA_CNDTRx寄存器中设置要传输的数据量。在每个数据传输后，这个数值递减。 在DMA_CCRx寄存器的PL[1:0]位中设置通道的优先级。 在DMA_CCRx寄存器中设置数据传输的方向、循环模式、外设和存储器的增量模式、外设和存储器的数据宽度、传输一半产生中断或传输完成产生中断。 设置DMA_CCRx寄存器的ENABLE位，启动该通道。一旦启动了DMA通道，它既可响应连到该通道上的外设的DMA请求。当传输一半的数据后，半传输标志(HTIF)被置1，当设置了允许半传输中断位(HTIE)时，将产生一个中断请求。在数据传输结束后，传输完成标志(TCIF)被置1，当设置了允许传输完成中断位(TCIE)时，将产生一个中断请求。 首先要先看文档手册就是STM32的手册，可知 ADC_DMA 属于通道1 USART1_TX_DMA 属于通道4 今天主要用到DMA的ADC采样与串口1的DMA发送。 ADC_DMA 配置如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &quot;adc.h&quot;vu16 ADC_DMA_IN[4]; //ADC数值存放的变量void ADC_DMA_Init(void)&#123; //DMA初始化设置 DMA_InitTypeDef DMA_InitStructure;//定义DMA初始化结构体 DMA_DeInit(DMA1_Channel1);//复位DMA通道1 DMA_InitStructure.DMA_PeripheralBaseAddr = ADC1_DR_Address; //定义 DMA通道外设基地址=ADC1_DR_Address DMA_InitStructure.DMA_MemoryBaseAddr = (u32)&amp;ADC_DMA_IN; //!!!定义DMA通道ADC数据存储器（其他函数可直接读此变量即是ADC值） DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;//指定外设为源地址 DMA_InitStructure.DMA_BufferSize = 4;//!!!定义DMA缓冲区大小（根据ADC采集通道数量修改） DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;//当前外设寄存器地址不变 DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;//!!! 当前存储器地址：Disable不变，Enable递增（用于多通道采集） DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;//定义外设数据宽度16位 DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord; //定义存储器数据宽度16位 DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;//DMA通道操作模式位环形缓冲模式 DMA_InitStructure.DMA_Priority = DMA_Priority_High;//DMA通道优先级高 DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;//禁止DMA通道存储器到存储器传输 DMA_Init(DMA1_Channel1, &amp;DMA_InitStructure);//初始化DMA通道1 DMA_Cmd(DMA1_Channel1, ENABLE); //使能DMA通道1&#125;void ADC_GPIO_Init(void)&#123; //GPIO初始化设置 GPIO_InitTypeDef GPIO_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA|RCC_APB2Periph_GPIOB|RCC_APB2Periph_GPIOC,ENABLE); RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);//使能DMA时钟（用于ADC的数据传送） RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);//使能ADC1时钟 GPIO_InitStructure.GPIO_Pin = ADC_CH4 | ADC_CH5 | ADC_CH6 | ADC_CH7; //!!!选择端口 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN; //选择IO接口工作方式 GPIO_Init(ADCPORT, &amp;GPIO_InitStructure); &#125;void ADC_Configuration(void)&#123; //初始化设置 ADC_InitTypeDef ADC_InitStructure;//定义ADC初始化结构体变量 ADC_GPIO_Init();//GPIO初始化设置 ADC_DMA_Init();//DMA初始化设置 ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;//ADC1和ADC2工作在独立模式 ADC_InitStructure.ADC_ScanConvMode = ENABLE; //使能扫描 ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;//ADC转换工作在连续模式 ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;//有软件控制转换 ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;//转换数据右对齐 ADC_InitStructure.ADC_NbrOfChannel = 4;//!!!顺序进行规则转换的ADC通道的数目（根据ADC采集通道数量修改） ADC_Init(ADC1, &amp;ADC_InitStructure); //根据ADC_InitStruct中指定的参数初始化外设ADCx的寄存器 //设置指定ADC的规则组通道，设置它们的转化顺序和采样时间 //ADC1,ADC通道x,规则采样顺序值为y,采样时间为28周期 ADC_RegularChannelConfig(ADC1, ADC_Channel_4, 1, ADC_SampleTime_28Cycles5);//!!! ADC1选择信道x,采样顺序y,采样时间n个周期 ADC_RegularChannelConfig(ADC1, ADC_Channel_5, 2, ADC_SampleTime_28Cycles5);//!!! ADC1选择信道x,采样顺序y,采样时间n个周期 ADC_RegularChannelConfig(ADC1, ADC_Channel_6, 3, ADC_SampleTime_28Cycles5);//!!! ADC1选择信道x,采样顺序y,采样时间n个周期 ADC_RegularChannelConfig(ADC1, ADC_Channel_7, 4, ADC_SampleTime_28Cycles5);//!!! ADC1选择信道x,采样顺序y,采样时间n个周期 ADC_DMACmd(ADC1, ENABLE);// 开启ADC的DMA支持（要实现DMA功能，还需独立配置DMA通道等参数） ADC_Cmd(ADC1, ENABLE);//使能ADC1 ADC_ResetCalibration(ADC1); //重置ADC1校准寄存器 while(ADC_GetResetCalibrationStatus(ADC1));//等待ADC1校准重置完成 ADC_StartCalibration(ADC1);//开始ADC1校准 while(ADC_GetCalibrationStatus(ADC1));//等待ADC1校准完成 ADC_SoftwareStartConvCmd(ADC1, ENABLE); //使能ADC1软件开始转换&#125; 12345678910111213141516171819#ifndef __ADC_H#define __ADC_H #include &quot;sys.h&quot;#define ADC1_DR_Address ((uint32_t)0x4001244C) //ADC1这个外设的地址（查参考手册得出）#define ADCPORT GPIOA //定义ADC接口#define ADC_CH4 GPIO_Pin_4 //定义ADC接口 电压电位器#define ADC_CH5 GPIO_Pin_5 //定义ADC接口 光敏电阻#define ADC_CH6 GPIO_Pin_6 //定义ADC接口 摇杆X轴#define ADC_CH7 GPIO_Pin_7 //定义ADC接口 摇杆Y轴void ADC_DMA_Init(void);void ADC_GPIO_Init(void);void ADC_Configuration(void);#endif USART1_TX_DMA 配置如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173#include &quot;bsp_usart_dma.h&quot;uint8_t SendBuff[SENDBUFF_SIZE];/** * @brief USART GPIO 配置,工作参数配置 * @param 无 * @retval 无 */void USART_Config(void)&#123; GPIO_InitTypeDef GPIO_InitStructure; USART_InitTypeDef USART_InitStructure; // 打开串口GPIO的时钟 DEBUG_USART_GPIO_APBxClkCmd(DEBUG_USART_GPIO_CLK, ENABLE); // 打开串口外设的时钟 DEBUG_USART_APBxClkCmd(DEBUG_USART_CLK, ENABLE); // 将USART Tx的GPIO配置为推挽复用模式 GPIO_InitStructure.GPIO_Pin = DEBUG_USART_TX_GPIO_PIN; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(DEBUG_USART_TX_GPIO_PORT, &amp;GPIO_InitStructure); // 将USART Rx的GPIO配置为浮空输入模式 GPIO_InitStructure.GPIO_Pin = DEBUG_USART_RX_GPIO_PIN; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING; GPIO_Init(DEBUG_USART_RX_GPIO_PORT, &amp;GPIO_InitStructure); // 配置串口的工作参数 // 配置波特率 USART_InitStructure.USART_BaudRate = DEBUG_USART_BAUDRATE; // 配置 针数据字长 USART_InitStructure.USART_WordLength = USART_WordLength_8b; // 配置停止位 USART_InitStructure.USART_StopBits = USART_StopBits_1; // 配置校验位 USART_InitStructure.USART_Parity = USART_Parity_No ; // 配置硬件流控制 USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None; // 配置工作模式，收发一起 USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx; // 完成串口的初始化配置 USART_Init(DEBUG_USARTx, &amp;USART_InitStructure); // 使能串口 USART_Cmd(DEBUG_USARTx, ENABLE); &#125;/***************** 发送一个字节 **********************/void Usart_SendByte( USART_TypeDef * pUSARTx, uint8_t ch)&#123; /* 发送一个字节数据到USART */ USART_SendData(pUSARTx,ch); /* 等待发送数据寄存器为空 */ while (USART_GetFlagStatus(pUSARTx, USART_FLAG_TXE) == RESET); &#125;/****************** 发送8位的数组 ************************/void Usart_SendArray( USART_TypeDef * pUSARTx, uint8_t *array, uint16_t num)&#123; uint8_t i; for(i=0; i&lt;num; i++) &#123; /* 发送一个字节数据到USART */ Usart_SendByte(pUSARTx,array[i]); &#125; /* 等待发送完成 */ while(USART_GetFlagStatus(pUSARTx,USART_FLAG_TC)==RESET);&#125;/***************** 发送字符串 **********************/void Usart_SendString( USART_TypeDef * pUSARTx, char *str)&#123; unsigned int k=0; do &#123; Usart_SendByte( pUSARTx, *(str + k) ); k++; &#125; while(*(str + k)!=&apos;\\0&apos;); /* 等待发送完成 */ while(USART_GetFlagStatus(pUSARTx,USART_FLAG_TC)==RESET) &#123;&#125;&#125;/***************** 发送一个16位数 **********************/void Usart_SendHalfWord( USART_TypeDef * pUSARTx, uint16_t ch)&#123; uint8_t temp_h, temp_l; /* 取出高八位 */ temp_h = (ch&amp;0XFF00)&gt;&gt;8; /* 取出低八位 */ temp_l = ch&amp;0XFF; /* 发送高八位 */ USART_SendData(pUSARTx,temp_h); while (USART_GetFlagStatus(pUSARTx, USART_FLAG_TXE) == RESET); /* 发送低八位 */ USART_SendData(pUSARTx,temp_l); while (USART_GetFlagStatus(pUSARTx, USART_FLAG_TXE) == RESET); &#125;///重定向c库函数printf到串口，重定向后可使用printf函数int fputc(int ch, FILE *f)&#123; /* 发送一个字节数据到串口 */ USART_SendData(DEBUG_USARTx, (uint8_t) ch); /* 等待发送完毕 */ while (USART_GetFlagStatus(DEBUG_USARTx, USART_FLAG_TXE) == RESET); return (ch);&#125;///重定向c库函数scanf到串口，重写向后可使用scanf、getchar等函数int fgetc(FILE *f)&#123; /* 等待串口输入数据 */ while (USART_GetFlagStatus(DEBUG_USARTx, USART_FLAG_RXNE) == RESET); return (int)USART_ReceiveData(DEBUG_USARTx);&#125;/** * @brief USARTx TX DMA 配置，内存到外设(USART1-&gt;DR) * @param 无 * @retval 无 */void USARTx_DMA_Config(void)&#123; DMA_InitTypeDef DMA_InitStructure; // 开启DMA时钟 RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE); // 设置DMA源地址：串口数据寄存器地址*/ DMA_InitStructure.DMA_PeripheralBaseAddr = USART_DR_ADDRESS; // 内存地址(要传输的变量的指针) DMA_InitStructure.DMA_MemoryBaseAddr = (u32)SendBuff; // 方向：从内存到外设 DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST; // 传输大小 DMA_InitStructure.DMA_BufferSize = SENDBUFF_SIZE; // 外设地址不增 DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable; // 内存地址自增 DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable; // 外设数据单位 DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte; // 内存数据单位 DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte; // DMA模式，一次或者循环模式 DMA_InitStructure.DMA_Mode = DMA_Mode_Normal ; //DMA_InitStructure.DMA_Mode = DMA_Mode_Circular; // 优先级：中 DMA_InitStructure.DMA_Priority = DMA_Priority_Medium; // 禁止内存到内存的传输 DMA_InitStructure.DMA_M2M = DMA_M2M_Disable; // 配置DMA通道 DMA_Init(USART_TX_DMA_CHANNEL, &amp;DMA_InitStructure); // 使能DMA DMA_Cmd (USART_TX_DMA_CHANNEL,ENABLE);&#125; 1234567891011121314151617181920212223242526272829303132333435#ifndef __USARTDMA_H#define __USARTDMA_H#include &quot;stm32f10x.h&quot;#include &lt;stdio.h&gt;// 串口工作参数宏定义#define DEBUG_USARTx USART1#define DEBUG_USART_CLK RCC_APB2Periph_USART1#define DEBUG_USART_APBxClkCmd RCC_APB2PeriphClockCmd#define DEBUG_USART_BAUDRATE 115200// USART GPIO 引脚宏定义#define DEBUG_USART_GPIO_CLK (RCC_APB2Periph_GPIOA)#define DEBUG_USART_GPIO_APBxClkCmd RCC_APB2PeriphClockCmd #define DEBUG_USART_TX_GPIO_PORT GPIOA #define DEBUG_USART_TX_GPIO_PIN GPIO_Pin_9#define DEBUG_USART_RX_GPIO_PORT GPIOA#define DEBUG_USART_RX_GPIO_PIN GPIO_Pin_10// 串口对应的DMA请求通道#define USART_TX_DMA_CHANNEL DMA1_Channel4// 外设寄存器地址#define USART_DR_ADDRESS (USART1_BASE+0x04)// 一次发送的数据量#define SENDBUFF_SIZE 5000void USART_Config(void);void USARTx_DMA_Config(void);#endif /* __USARTDMA_H */","categories":[],"tags":[{"name":"STM32","slug":"STM32","permalink":"http://yoursite.com/tags/STM32/"}]},{"title":"M5311模组烤机测试装置","slug":"M5311模组烤机测试装置（Arduino）","date":"2019-04-01T02:53:00.000Z","updated":"2019-04-15T17:15:40.420Z","comments":true,"path":"2019/04/01/M5311模组烤机测试装置（Arduino）/","link":"","permalink":"http://yoursite.com/2019/04/01/M5311模组烤机测试装置（Arduino）/","excerpt":"项目要求：由于只是测试程序 所以我采用了arduino promini 来完成。 测试NB模组长时间工作的稳定性。 测试NB模组收发数据的延迟。 测试AT指令的稳定性。","text":"项目要求：由于只是测试程序 所以我采用了arduino promini 来完成。 测试NB模组长时间工作的稳定性。 测试NB模组收发数据的延迟。 测试AT指令的稳定性。 由于公司部门工作需要，我们采购了移动的NB模组M5311，并绘制了PCB（PCB板是同事画的），最后我进行了AT指令的测试，效果还是很好的数据很稳定，然后准备做一个硬件对这款NB模组进行长时间烤机进行稳定性测试 模组采用移动M5311 http://iot.10086.cn/chipmodule/read/id/501 单片机采用 Arduino pro mini 进行测试。 测试代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115/* 基于NBIOT的MQTT协议PCB测试代码 主要用于测试NB模组的耐久度与稳定性 便于PCB批量测试 开发者：阿正 wenzheng.club 备注：由于NB模组普遍存在AT指令无返回或者偶然出错的情况，所以本程序多次采用while（1），来保证AT指令接收，进而进行下一条指令的发送。 ***其中命令发送与返回校验 模仿Stm32串口中断来实现的逻辑处理*/#include &lt;SoftwareSerial.h&gt; //虚拟串口库SoftwareSerial mySerial(10, 11); // RX, TX 虚拟串口方便调试 11-&gt;NBTXString AT = &quot;AT&quot;;String open_led = &quot;AT+CMSYSCTRL=0,2&quot;;String Set_Mqtt = &quot;AT+MQTTCFG=\\&quot;服务器ip\\&quot;,1883,\\&quot;ZXNBiot_mini\\&quot;,60,\\&quot;root\\&quot;,\\&quot;citc2018\\&quot;,1&quot;;String Clint_Mqtt = &quot;AT+MQTTOPEN=1,1,1,1,1,\\&quot;mywill\\&quot;,\\&quot;001bye\\&quot;&quot;;String Publish_msg = &quot;AT+MQTTPUB=\\&quot;/device/NB/pengwenzheng\\&quot;,1,1,0,0,\\&quot;2019$\\&quot;&quot;;String inputString = &quot;&quot;;bool stringComplete = false;void setup() &#123; Serial.begin(9600); mySerial.begin(9600); pinMode(12, OUTPUT); //硬复位NB模组 pinMode(13, OUTPUT); //状态指示灯 inputString.reserve(400); delay(2000); MQTT_int(); //MQTT初始化&#125;void loop() &#123; if (Send_MQTT(Publish_msg, 50)) //发送成功则快闪一次 &#123; digitalWrite(13, 1); delay(200); &#125; digitalWrite(13, 0); delay(5000);//每5秒发送一次&#125;void MQTT_int() &#123; digitalWrite(12, 0); delay(2000); digitalWrite(12, 1); delay(500); digitalWrite(12, 0); Serial.println(&quot;Begin.....&quot;); while (!Send_MQTT(open_led, 50)); //循环发送LED配置命令 直到返回OK代表成功 delay(500); while (1) &#123; //一直等待连接IP地址 serialEvent(); if ( inputString.indexOf(&quot;+IP&quot;) != -1) &#123; digitalWrite(13, 1); delay(1000); digitalWrite(13, 0); break; &#125; else Serial.println(&quot;Wait...&quot;); &#125; while (1) &#123; if (Send_MQTT(Set_Mqtt, 60) == 1) &#123; while (!Send_MQTT(Clint_Mqtt, 60)); Serial.println(&quot;Clint_Mqtt!!!&quot;); break; &#125; delay(1000); &#125;&#125;/* * 函数名称：Send_MQTT(String msg, int wait) * 入口参数： * msg 发送的AT指令码 * wait 数据延时 * 出口参数： * 1 数据返回成功即代表此次发送指令有效 * 0 数据返回失败即代表此次数据发送失败 * 备注：模仿Stm32串口中断来实现的数据返回处理 */int Send_MQTT(String msg, int wait) &#123; delay(1000); mySerial.println(msg); delay(wait); serialEvent(); if (stringComplete) &#123; delay(100); if ( inputString.indexOf(&quot;OK&quot;) != -1) &#123; Serial.println(inputString); inputString = &quot;&quot;; //清除标志位 stringComplete = false; //清除标志位 while (Serial.read() &gt;= 0) &#123;&#125;; //清空串口缓存 return 1; &#125; else if ( inputString.indexOf(&quot;ERROR&quot;) != -1) &#123; Serial.println(inputString); inputString = &quot;&quot;; stringComplete = false; while (Serial.read() &gt;= 0) &#123;&#125;; return 0; &#125; &#125;&#125;/* * 函数名称：Send_MQTT(String msg, int wait) * 入口参数： * msg 发送的AT指令码 * wait 数据延时 * 出口参数： * 1 数据返回成功即代表此次发送指令有效 * 0 数据返回失败即代表此次数据发送失败 * 备注：模仿Stm32串口中断来实现的数据返回处理 */void serialEvent() &#123; while (mySerial.available()) &#123; char inChar = (char)mySerial.read(); inputString += inChar; if (inChar == &apos;\\n&apos;) &#123; stringComplete = true; &#125; &#125;&#125; 具体的实现方法为：利用arduino promini 的虚拟串口来调试AT指令，然后利用其朱串口进行数据打印调试。备注：其中最重要的是现有的需要AT指令的模组都需要进行返回值的判断以及顺序进行AT指令的发送，例如服务器的连接，需要提前进行服务器配置，之后再进行服务器的连接，上一步如果出错 则无法进行下一步的指令发送。代码里多次使用while循环来实现了命令返回值判断。例如：1while (!Send_MQTT(open_led, 50)); //循环发送LED配置命令 直到返回OK代表成功 其中Send_MQTT(String msg, int wait)函数就是采用的模拟Stm32串口中断来实现的快速数据返回校验。","categories":[],"tags":[{"name":"NBIOT","slug":"NBIOT","permalink":"http://yoursite.com/tags/NBIOT/"}]},{"title":"公司项目代码调试总结","slug":"公司项目代码调试总结","date":"2019-03-28T15:31:00.000Z","updated":"2019-03-28T16:14:10.843Z","comments":true,"path":"2019/03/28/公司项目代码调试总结/","link":"","permalink":"http://yoursite.com/2019/03/28/公司项目代码调试总结/","excerpt":"最近公司做了一系列的项目，我也是负责好几个项目并行开发，也是很吃力，很紧张，幸好今天进展还算顺利。 STM32程序编写记录 今天最难调试的是 一个485IC，明天开始调试移动M5311的NBiot模组。程序写的没毛病，但是总是出错 我也很无语，最后查了一些资料终于搞定了，很开心。","text":"最近公司做了一系列的项目，我也是负责好几个项目并行开发，也是很吃力，很紧张，幸好今天进展还算顺利。 STM32程序编写记录 今天最难调试的是 一个485IC，明天开始调试移动M5311的NBiot模组。程序写的没毛病，但是总是出错 我也很无语，最后查了一些资料终于搞定了，很开心。 代码记录如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/***********************************************************函数名称：int RS485_SendCmd(u8 *cmd,u8 len,int x,int wait)函数功能：RS485问询与返回指令入口参数：cmd：问询指令 len：数据长度 x：数据起始位 wait：问询延时出口参数：数据点备 注：***********************************************************/ int RS485_SendCmd(u8 *cmd,u8 len,int x,int wait)&#123; int Val = 0; int i; unsigned short CRC_Tmp; unsigned short crc; struct_usart3.USART_Length = 0; printf(&quot;[RS485_SendCmd] %d\\r\\n&quot;,len); GPIO_SetBits(GPIOB,GPIO_Pin_1); delay_ms(2); uart3_send_buff(cmd, len); delay_ms(2);//稍稍延时一下，原因去查看sp3485的手册吧 GPIO_ResetBits(GPIOB, GPIO_Pin_1); delay_ms(wait); if (struct_usart3.USART_Length != 0) //返回值不为空 &#123; //for(i=0;i&lt;len+1;i++) //打印出来接收的包共9个数据 //&#123; //printf(&quot;%X@&quot;,struct_usart3.USART_BUFF[i]); //&#125; // printf(&quot;%d&quot;,struct_usart3.USART_Length); GPIO_SetBits(GPIOB,GPIO_Pin_1); delay_ms(2);//稍稍延时一下，原因去查看sp3485的手册吧 crc = ((unsigned short)struct_usart3.USART_BUFF[struct_usart3.USART_Length-2]&lt;&lt;8) + struct_usart3.USART_BUFF[struct_usart3.USART_Length-1]; //收到数据的crc校验值 CRC_Tmp = CRC_16_HEX(struct_usart3.USART_BUFF,struct_usart3.USART_Length-2); //处理除去最后两位的数据CRC校验，算出crc校验值 //printf(&quot;%X\\r\\n&quot;,crc); //printf(&quot;%X\\r\\n&quot;,CRC_Tmp); if (CRC_Tmp == crc)&#123; //比较CRC校验值是否相等，相等则进行下一步处理 Val = (struct_usart3.USART_BUFF[x]*256) + (struct_usart3.USART_BUFF[x+1]*1); struct_usart3.USART_BUFF[struct_usart3.USART_Length] = &apos;\\0&apos;; //清零 return Val; &#125; struct_usart3.USART_BUFF[struct_usart3.USART_Length] = &apos;\\0&apos;; //清零 return Val; &#125; &#125; 其中最重要的是485EN使能端口的配置，以及发送和接收数据时的上拉和下拉配置。 12345 GPIO_SetBits(GPIOB,GPIO_Pin_1);delay_ms(2); uart3_send_buff(cmd, len);delay_ms(2);//稍稍延时一下，原因去查看sp3485的手册吧GPIO_ResetBits(GPIOB, GPIO_Pin_1); “delay_ms(2);” 延时非常重要！！发送数据前 先把EN脚拉高，然后发送数据 ，数据发送完将EN再拉低，进入接收中断以后，确保接收到数据立即将EN复位（拉高）进行下一次的准备。 致此，公司此项目开发的新PCB，代码我已全部调通，明天进行NB调试与设备装机调试，并且进行其它传感器的校验。","categories":[],"tags":[{"name":"Siri","slug":"Siri","permalink":"http://yoursite.com/tags/Siri/"}]},{"title":"一行代码完成485通讯与数据回传以及CRC校验","slug":"一行代码完成485通讯与数据回传以及CRC校验","date":"2019-03-16T13:10:00.000Z","updated":"2019-03-16T13:57:45.052Z","comments":true,"path":"2019/03/16/一行代码完成485通讯与数据回传以及CRC校验/","link":"","permalink":"http://yoursite.com/2019/03/16/一行代码完成485通讯与数据回传以及CRC校验/","excerpt":"由于工作需要，我对现有的485通讯方式进行了一个总结，同时也包含自己原创的一些算法来快速实现485通讯与CRC校验，以及返回值的处理 看下效果：利用此方法可以一行代码完成485发送与接收而且还包含了CRC16Modbus校验！","text":"由于工作需要，我对现有的485通讯方式进行了一个总结，同时也包含自己原创的一些算法来快速实现485通讯与CRC校验，以及返回值的处理 看下效果：利用此方法可以一行代码完成485发送与接收而且还包含了CRC16Modbus校验！ RS485通讯 我个人认为485的通讯协议只是一个规则而已，现在懂得运用即可，我就不再这里长篇阔论的进行原理讲解，毕竟我也不懂，你也不懂，不如直接实战，开搞！而且从单片机角度来看，485就是串口通讯，加了串口转换模块而已，所以只要把串口处理好就可以了。 首先看一下串口处理的方法 我尝试了很多方法，发现现在用的是最方便的一个。 首先是建立结构体进行数据存储。123456789101112/*初始化串口 *///定义结构体用来存储接收数据typedef struct &#123; u8 USART_BUFF[100]; unsigned short RxBuf[100]; int USART_Length; int flag;&#125;Usart_Struct;Usart_Struct struct_usart2; 其次是初始化与硬件配置（可以忽略不看） 12345678910111213141516171819202122232425262728293031323334353637383940414243void usart2_init(u32 band)&#123; //GPIO端口设置 GPIO_InitTypeDef GPIO_InitStructure; USART_InitTypeDef USART_InitStructure; NVIC_InitTypeDef NVIC_InitStructure; RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE); //使能USART2 RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); // //重新定义管脚 //GPIO_PinRemapConfig(GPIO_Remap_USART2,ENABLE); //USART2_TX GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2; // 引脚不能更改 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; //复用推挽输出 GPIO_Init(GPIOA, &amp;GPIO_InitStructure);//初始化 //USART2_RX GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;//PA GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;//浮空输入 GPIO_Init(GPIOA, &amp;GPIO_InitStructure);//初始化 //Usart NVIC 配置 NVIC_InitStructure.NVIC_IRQChannel = USART2_IRQn; NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=1;//抢占优先级3 原3 NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3; //子优先级3 原2 NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //IRQ通道使能 NVIC_Init(&amp;NVIC_InitStructure); //根据指定的参数初始化VIC寄存器 //USART 初始化设置 USART_InitStructure.USART_BaudRate = band;//串口波特率 USART_InitStructure.USART_WordLength = USART_WordLength_8b;//字长为8位数据格式 USART_InitStructure.USART_StopBits = USART_StopBits_1;//一个停止位 USART_InitStructure.USART_Parity = USART_Parity_No;//无奇偶校验位 USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;//无硬件数据流控制 USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx; //收发模式 USART_Init(USART2, &amp;USART_InitStructure); //初始化串口2 USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);//开启串口接受中断 USART_Cmd(USART2, ENABLE); //使能串口2&#125; 然后重要的在于串口终端函数 1234567891011121314151617181920/*串口2中断函数*/void USART2_IRQHandler(void) //串口2中断服务程序 &#123; u8 ch; if(USART_GetITStatus(USART2,USART_IT_RXNE) != RESET) //接收到数据 &#123; USART_ClearITPendingBit(USART2,USART_IT_RXNE); ch = (u8)USART_ReceiveData(USART2); struct_usart2.USART_BUFF[struct_usart2.USART_Length++] = ch; struct_usart2.flag = 1; &#125; if( USART_GetITStatus( USART2, USART_IT_IDLE ) == SET ) &#123; USART_ClearITPendingBit(USART2,USART_IT_IDLE); struct_usart2.flag = 1; ch = (u8)USART_ReceiveData(USART2); &#125; &#125; 解释：这里的效果在于，可以很快速的对数据进行处理同时将数据缓存至结构体比那两种 最重要的就是发送指令与数据回传的综合处理函数！！！ 1234567891011121314151617181920212223242526272829303132333435363738394041/***********************************************************函数名称：int RS485_SendCmd(u8 *cmd,u8 len,int x,int wait)函数功能：RS485问询与返回指令入口参数：cmd：问询指令 len：数据长度 x：数据起始位 wait：问询延时出口参数：数据点备 注：***********************************************************/ int RS485_SendCmd(u8 *cmd,u8 len,int x,int wait)&#123; int Val = 0; int i; unsigned short CRC_Tmp; unsigned short crc; struct_usart2.USART_Length = 0; printf(&quot;[RS485_SendCmd] %s\\r\\n&quot;,&quot;OK&quot;); uart2_send_buff(cmd, len); delay_ms(wait); if (struct_usart2.USART_Length != 0) //返回值不为空 &#123; //for(i=0;i&lt;len+1;i++) //打印出来接收的包共9个数据 //&#123; //printf(&quot;%X@&quot;,struct_usart2.USART_BUFF[i]); //&#125; //printf(&quot;%d&quot;,struct_usart2.USART_Length); crc = ((unsigned short)struct_usart2.USART_BUFF[struct_usart2.USART_Length-2]&lt;&lt;8) + struct_usart2.USART_BUFF[struct_usart2.USART_Length-1]; //收到数据的crc校验值 CRC_Tmp = CRC_16_HEX(struct_usart2.USART_BUFF,struct_usart2.USART_Length-2); //处理除去最后两位的数据CRC校验，算出crc校验值 //printf(&quot;%X\\r\\n&quot;,crc); //printf(&quot;%X\\r\\n&quot;,CRC_Tmp); if (CRC_Tmp == crc)&#123; //比较CRC校验值是否相等，相等则进行下一步处理 Val = (struct_usart2.USART_BUFF[x]*256) + (struct_usart2.USART_BUFF[x+1]*1); struct_usart2.USART_BUFF[struct_usart2.USART_Length] = &apos;\\0&apos;; //清零 return Val; &#125; struct_usart2.USART_BUFF[struct_usart2.USART_Length] = &apos;\\0&apos;; //清零 return Val; &#125; &#125; 解释：这里的终极奥义就在于可以一个函数完成数据发送与接收和校验！原理分析：在设备串口问询485数据后，会立即进入接收串口接收中断，同时将接收的数据存入结构体，然后进行返回值除去后两位的CRC校验判断是否与返回的数据相等，如果满足CRC校验，就确认为正常数据。接下来可用于NB的发送。 源码由博客主页Github获取","categories":[],"tags":[{"name":"STM32","slug":"STM32","permalink":"http://yoursite.com/tags/STM32/"}]},{"title":"安卓蓝牙小项目总结","slug":"安卓蓝牙小项目总结","date":"2019-03-10T15:43:00.000Z","updated":"2019-03-10T16:32:22.938Z","comments":true,"path":"2019/03/10/安卓蓝牙小项目总结/","link":"","permalink":"http://yoursite.com/2019/03/10/安卓蓝牙小项目总结/","excerpt":"这次的项目比较特殊。。。居然是。。。既然是！！它！！—51单片机，（-.-），说句实话 我的单片机和C语言基础巨差，而且我根本没玩过51单片机。所以这个老掉牙的东一还是蛮有挑战性的。 视频如下： 总体的思路也是物联网相关的，采用的是蓝牙通讯，做这个东西有意思的地方在于安卓软件的开发。因为我对java也不是太了解，所以可以根据项目来提高自己。","text":"这次的项目比较特殊。。。居然是。。。既然是！！它！！—51单片机，（-.-），说句实话 我的单片机和C语言基础巨差，而且我根本没玩过51单片机。所以这个老掉牙的东一还是蛮有挑战性的。 视频如下： 总体的思路也是物联网相关的，采用的是蓝牙通讯，做这个东西有意思的地方在于安卓软件的开发。因为我对java也不是太了解，所以可以根据项目来提高自己。 总体做下来还是有收获的，而且阴差阳错的自己又去学了Pr，因为做视频剪辑需要用到它，总之知识都是互通的，尽量让自己的知识面宽广一点，懂得多一点肯定没坏处！ 不行今天就先总结到这里吧，我得睡觉了，明天要上班。","categories":[],"tags":[{"name":"android","slug":"android","permalink":"http://yoursite.com/tags/android/"}]},{"title":"关于WZ指令的配网与烧写固件","slug":"关于WZ指令的配网与烧写固件","date":"2019-02-27T13:56:00.000Z","updated":"2019-02-27T14:48:00.555Z","comments":true,"path":"2019/02/27/关于WZ指令的配网与烧写固件/","link":"","permalink":"http://yoursite.com/2019/02/27/关于WZ指令的配网与烧写固件/","excerpt":"智能配网说明 配网说明：wifi模组是自带智能配网功能的，所以用可以配网的软件即可、例如机智云的软件、小米的软件、天猫精灵配置软件等等。因为他们的配置原理都是一样的。下面介绍一种最简单的方法—–微信！","text":"智能配网说明 配网说明：wifi模组是自带智能配网功能的，所以用可以配网的软件即可、例如机智云的软件、小米的软件、天猫精灵配置软件等等。因为他们的配置原理都是一样的。下面介绍一种最简单的方法—–微信！ 配置步骤： 首先ESP01上电会闪一下。 成功烧写固件后初次上电会直接进入快闪模式即配网模式（200毫秒间歇闪烁） 如果之前配置过wifi网络则开机约3秒后直接联网进入工作状态：（每2秒闪一次代表联网正常）同时串口打印： 12wifi_OKplease connect the server! 如果进入新的wifi环境，模组上电将一直尝试登陆上次配置的wifi，10秒后仍未连接wifi则进入配网模式即上面所说的（200毫秒间歇闪烁）同时串口打印： 1................... 此时请保证手机已连接要配置的wifi，然后微信扫一扫上方二维码，进行配置。等待若干秒，ESP01指示灯短暂熄灭，进入慢闪模式代表配置成功，以后不需要再配置。同时串口打印wifi名称和密码以及上方联网成功字样。 固件烧写说明： 烧写位置：0x00000000注：1.ESP01 EN与VCC接3.3V且保证供电充足，最好独立供电，但要与usbttl共地2.GPIO0要接GND才可以进入烧写模式3.按照下图选择好文件路径与烧写位置以后，配置好各项参数，先清除flash即点击ERASE按钮，此时会显示“正在等待上电重启”，此时将ESP01模组的VCC拔掉再插上即可进入擦除状态。4.擦除成功以后，点击START按钮进入烧写模式，重复上一步中的—-此时会显示“正在等待上电重启”，此时将ESP01模组的VCC拔掉再插上即可进入烧写状态。5.等进入条完成，拔掉GPIO0的GND线，令其悬空即可进入工作模式。6.配网、调试、接单片机即可工作。 如果依然有问题的话可以留言。实在不行我就再录一个视频。","categories":[],"tags":[{"name":"WZ指令","slug":"WZ指令","permalink":"http://yoursite.com/tags/WZ指令/"}]},{"title":"STM32多通道DMA—ADC采样","slug":"STM32多通道DMA—ADC采样","date":"2019-02-26T14:30:00.000Z","updated":"2019-02-26T15:04:40.268Z","comments":true,"path":"2019/02/26/STM32多通道DMA—ADC采样/","link":"","permalink":"http://yoursite.com/2019/02/26/STM32多通道DMA—ADC采样/","excerpt":"阿正的个人站学习笔记–STM32多通道DMA—ADC采样 资料来源于杜洋工作室，视频：https://www.bilibili.com/video/av18222153/?p=9 普通的ADC采样，一般直接采用通道即可，但是利用DMA可以实现快速的数据读取，而且可以实现单片机的高效率运行。–特记录代码来加深印象！从大学在图书馆就看杜洋老师的书，2018他又出了最新的视频教程，非常详细，注释感人！ 学习总结：DMA就像一个缓存数据一样，可以减轻cpu的负担。 使用DMA的话首先要确定外设的基地址。 设定缓冲区大小（多通道ADC） 开启允许多通道（多通道ADC） 允许地址偏移（多通道ADC） 使用ADC的话就单独配置即可 希望自己过几天能独立完成DMA的串口接收 adc.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &quot;adc.h&quot;vu16 ADC_DMA_IN[2]; //ADC数值存放的变量void ADC_DMA_Init(void)&#123; //DMA初始化设置 DMA_InitTypeDef DMA_InitStructure;//定义DMA初始化结构体 DMA_DeInit(DMA1_Channel1);//复位DMA通道1 DMA_InitStructure.DMA_PeripheralBaseAddr = ADC1_DR_Address; //定义 DMA通道外设基地址=ADC1_DR_Address DMA_InitStructure.DMA_MemoryBaseAddr = (u32)&amp;ADC_DMA_IN; //!!!定义DMA通道ADC数据存储器（其他函数可直接读此变量即是ADC值） DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;//指定外设为源地址 DMA_InitStructure.DMA_BufferSize = 2;//!!!定义DMA缓冲区大小（根据ADC采集通道数量修改） DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;//当前外设寄存器地址不变 DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;//!!! 当前存储器地址：Disable不变，Enable递增（用于多通道采集） DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;//定义外设数据宽度16位 DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord; //定义存储器数据宽度16位 DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;//DMA通道操作模式位环形缓冲模式 DMA_InitStructure.DMA_Priority = DMA_Priority_High;//DMA通道优先级高 DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;//禁止DMA通道存储器到存储器传输 DMA_Init(DMA1_Channel1, &amp;DMA_InitStructure);//初始化DMA通道1 DMA_Cmd(DMA1_Channel1, ENABLE); //使能DMA通道1&#125;void ADC_GPIO_Init(void)&#123; //GPIO初始化设置 GPIO_InitTypeDef GPIO_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA|RCC_APB2Periph_GPIOB|RCC_APB2Periph_GPIOC,ENABLE); RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);//使能DMA时钟（用于ADC的数据传送） RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);//使能ADC1时钟 GPIO_InitStructure.GPIO_Pin = ADC_CH4 | ADC_CH5; //!!!选择端口 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN; //选择IO接口工作方式 GPIO_Init(ADCPORT, &amp;GPIO_InitStructure); &#125;void ADC_Configuration(void)&#123; //初始化设置 ADC_InitTypeDef ADC_InitStructure;//定义ADC初始化结构体变量 ADC_GPIO_Init();//GPIO初始化设置 ADC_DMA_Init();//DMA初始化设置 ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;//ADC1和ADC2工作在独立模式 ADC_InitStructure.ADC_ScanConvMode = ENABLE; //使能扫描 ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;//ADC转换工作在连续模式 ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;//有软件控制转换 ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;//转换数据右对齐 ADC_InitStructure.ADC_NbrOfChannel = 2;//!!!顺序进行规则转换的ADC通道的数目（根据ADC采集通道数量修改） ADC_Init(ADC1, &amp;ADC_InitStructure); //根据ADC_InitStruct中指定的参数初始化外设ADCx的寄存器 //设置指定ADC的规则组通道，设置它们的转化顺序和采样时间 //ADC1,ADC通道x,规则采样顺序值为y,采样时间为28周期 ADC_RegularChannelConfig(ADC1, ADC_Channel_4, 1, ADC_SampleTime_28Cycles5);//!!! ADC1选择信道x,采样顺序y,采样时间n个周期 ADC_RegularChannelConfig(ADC1, ADC_Channel_5, 2, ADC_SampleTime_28Cycles5);//!!! ADC1选择信道x,采样顺序y,采样时间n个周期 ADC_DMACmd(ADC1, ENABLE);// 开启ADC的DMA支持（要实现DMA功能，还需独立配置DMA通道等参数） ADC_Cmd(ADC1, ENABLE);//使能ADC1 ADC_ResetCalibration(ADC1); //重置ADC1校准寄存器 while(ADC_GetResetCalibrationStatus(ADC1));//等待ADC1校准重置完成 ADC_StartCalibration(ADC1);//开始ADC1校准 while(ADC_GetCalibrationStatus(ADC1));//等待ADC1校准完成 ADC_SoftwareStartConvCmd(ADC1, ENABLE); //使能ADC1软件开始转换&#125; adc.h 12345678910111213141516171819#ifndef __ADC_H#define __ADC_H #include &quot;sys.h&quot;#define ADC1_DR_Address ((uint32_t)0x4001244C) //ADC1这个外设的地址（查参考手册得出）#define ADCPORT GPIOA //定义ADC接口#define ADC_CH4 GPIO_Pin_4 //定义ADC接口 电压电位器#define ADC_CH5 GPIO_Pin_5 //定义ADC接口 光敏电阻#define ADC_CH6 GPIO_Pin_6 //定义ADC接口 摇杆X轴#define ADC_CH7 GPIO_Pin_7 //定义ADC接口 摇杆Y轴void ADC_DMA_Init(void);void ADC_GPIO_Init(void);void ADC_Configuration(void);#endif main.c 1234567891011121314151617181920212223242526272829303132#include &quot;delay.h&quot;#include &quot;touch_key.h&quot;#include &quot;relay.h&quot;#include &quot;oled0561.h&quot;#include &quot;adc.h&quot;extern vu16 ADC_DMA_IN[2]; //声明外部变量int main (void)&#123;//主程序 delay_ms(500); //上电时等待其他器件就绪 RCC_Configuration(); //系统时钟初始化 TOUCH_KEY_Init();//触摸按键初始化 RELAY_Init();//继电器初始化 ADC_Configuration(); //ADC初始化设置 I2C_Configuration();//I2C初始化 OLED0561_Init(); //OLED初始化 OLED_DISPLAY_8x16_BUFFER(0,&quot; YoungTalk &quot;); //显示字符串 OLED_DISPLAY_8x16_BUFFER(2,&quot; ADC TEST &quot;); //显示字符串 OLED_DISPLAY_8x16_BUFFER(4,&quot; ADC_IN4: &quot;); //显示字符串 OLED_DISPLAY_8x16_BUFFER(6,&quot; ADC_IN5: &quot;); //显示字符串 while(1)&#123; //将光敏电阻的ADC数据显示在OLED上 OLED_DISPLAY_8x16(4,10*8,ADC_DMA_IN[0]/1000+0x30);// OLED_DISPLAY_8x16(4,11*8,ADC_DMA_IN[0]%1000/100+0x30);// OLED_DISPLAY_8x16(4,12*8,ADC_DMA_IN[0]%100/10+0x30);// OLED_DISPLAY_8x16(4,13*8,ADC_DMA_IN[0]%10+0x30);// OLED_DISPLAY_8x16(6,10*8,ADC_DMA_IN[1]/1000+0x30);// OLED_DISPLAY_8x16(6,11*8,ADC_DMA_IN[1]%1000/100+0x30);// OLED_DISPLAY_8x16(6,12*8,ADC_DMA_IN[1]%100/10+0x30);// OLED_DISPLAY_8x16(6,13*8,ADC_DMA_IN[1]%10+0x30);// delay_ms(500); //延时 &#125;&#125;","text":"阿正的个人站学习笔记–STM32多通道DMA—ADC采样 资料来源于杜洋工作室，视频：https://www.bilibili.com/video/av18222153/?p=9 普通的ADC采样，一般直接采用通道即可，但是利用DMA可以实现快速的数据读取，而且可以实现单片机的高效率运行。–特记录代码来加深印象！从大学在图书馆就看杜洋老师的书，2018他又出了最新的视频教程，非常详细，注释感人！ 学习总结：DMA就像一个缓存数据一样，可以减轻cpu的负担。 使用DMA的话首先要确定外设的基地址。 设定缓冲区大小（多通道ADC） 开启允许多通道（多通道ADC） 允许地址偏移（多通道ADC） 使用ADC的话就单独配置即可 希望自己过几天能独立完成DMA的串口接收 adc.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &quot;adc.h&quot;vu16 ADC_DMA_IN[2]; //ADC数值存放的变量void ADC_DMA_Init(void)&#123; //DMA初始化设置 DMA_InitTypeDef DMA_InitStructure;//定义DMA初始化结构体 DMA_DeInit(DMA1_Channel1);//复位DMA通道1 DMA_InitStructure.DMA_PeripheralBaseAddr = ADC1_DR_Address; //定义 DMA通道外设基地址=ADC1_DR_Address DMA_InitStructure.DMA_MemoryBaseAddr = (u32)&amp;ADC_DMA_IN; //!!!定义DMA通道ADC数据存储器（其他函数可直接读此变量即是ADC值） DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;//指定外设为源地址 DMA_InitStructure.DMA_BufferSize = 2;//!!!定义DMA缓冲区大小（根据ADC采集通道数量修改） DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;//当前外设寄存器地址不变 DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;//!!! 当前存储器地址：Disable不变，Enable递增（用于多通道采集） DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;//定义外设数据宽度16位 DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord; //定义存储器数据宽度16位 DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;//DMA通道操作模式位环形缓冲模式 DMA_InitStructure.DMA_Priority = DMA_Priority_High;//DMA通道优先级高 DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;//禁止DMA通道存储器到存储器传输 DMA_Init(DMA1_Channel1, &amp;DMA_InitStructure);//初始化DMA通道1 DMA_Cmd(DMA1_Channel1, ENABLE); //使能DMA通道1&#125;void ADC_GPIO_Init(void)&#123; //GPIO初始化设置 GPIO_InitTypeDef GPIO_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA|RCC_APB2Periph_GPIOB|RCC_APB2Periph_GPIOC,ENABLE); RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);//使能DMA时钟（用于ADC的数据传送） RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);//使能ADC1时钟 GPIO_InitStructure.GPIO_Pin = ADC_CH4 | ADC_CH5; //!!!选择端口 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN; //选择IO接口工作方式 GPIO_Init(ADCPORT, &amp;GPIO_InitStructure); &#125;void ADC_Configuration(void)&#123; //初始化设置 ADC_InitTypeDef ADC_InitStructure;//定义ADC初始化结构体变量 ADC_GPIO_Init();//GPIO初始化设置 ADC_DMA_Init();//DMA初始化设置 ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;//ADC1和ADC2工作在独立模式 ADC_InitStructure.ADC_ScanConvMode = ENABLE; //使能扫描 ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;//ADC转换工作在连续模式 ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;//有软件控制转换 ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;//转换数据右对齐 ADC_InitStructure.ADC_NbrOfChannel = 2;//!!!顺序进行规则转换的ADC通道的数目（根据ADC采集通道数量修改） ADC_Init(ADC1, &amp;ADC_InitStructure); //根据ADC_InitStruct中指定的参数初始化外设ADCx的寄存器 //设置指定ADC的规则组通道，设置它们的转化顺序和采样时间 //ADC1,ADC通道x,规则采样顺序值为y,采样时间为28周期 ADC_RegularChannelConfig(ADC1, ADC_Channel_4, 1, ADC_SampleTime_28Cycles5);//!!! ADC1选择信道x,采样顺序y,采样时间n个周期 ADC_RegularChannelConfig(ADC1, ADC_Channel_5, 2, ADC_SampleTime_28Cycles5);//!!! ADC1选择信道x,采样顺序y,采样时间n个周期 ADC_DMACmd(ADC1, ENABLE);// 开启ADC的DMA支持（要实现DMA功能，还需独立配置DMA通道等参数） ADC_Cmd(ADC1, ENABLE);//使能ADC1 ADC_ResetCalibration(ADC1); //重置ADC1校准寄存器 while(ADC_GetResetCalibrationStatus(ADC1));//等待ADC1校准重置完成 ADC_StartCalibration(ADC1);//开始ADC1校准 while(ADC_GetCalibrationStatus(ADC1));//等待ADC1校准完成 ADC_SoftwareStartConvCmd(ADC1, ENABLE); //使能ADC1软件开始转换&#125; adc.h 12345678910111213141516171819#ifndef __ADC_H#define __ADC_H #include &quot;sys.h&quot;#define ADC1_DR_Address ((uint32_t)0x4001244C) //ADC1这个外设的地址（查参考手册得出）#define ADCPORT GPIOA //定义ADC接口#define ADC_CH4 GPIO_Pin_4 //定义ADC接口 电压电位器#define ADC_CH5 GPIO_Pin_5 //定义ADC接口 光敏电阻#define ADC_CH6 GPIO_Pin_6 //定义ADC接口 摇杆X轴#define ADC_CH7 GPIO_Pin_7 //定义ADC接口 摇杆Y轴void ADC_DMA_Init(void);void ADC_GPIO_Init(void);void ADC_Configuration(void);#endif main.c 1234567891011121314151617181920212223242526272829303132#include &quot;delay.h&quot;#include &quot;touch_key.h&quot;#include &quot;relay.h&quot;#include &quot;oled0561.h&quot;#include &quot;adc.h&quot;extern vu16 ADC_DMA_IN[2]; //声明外部变量int main (void)&#123;//主程序 delay_ms(500); //上电时等待其他器件就绪 RCC_Configuration(); //系统时钟初始化 TOUCH_KEY_Init();//触摸按键初始化 RELAY_Init();//继电器初始化 ADC_Configuration(); //ADC初始化设置 I2C_Configuration();//I2C初始化 OLED0561_Init(); //OLED初始化 OLED_DISPLAY_8x16_BUFFER(0,&quot; YoungTalk &quot;); //显示字符串 OLED_DISPLAY_8x16_BUFFER(2,&quot; ADC TEST &quot;); //显示字符串 OLED_DISPLAY_8x16_BUFFER(4,&quot; ADC_IN4: &quot;); //显示字符串 OLED_DISPLAY_8x16_BUFFER(6,&quot; ADC_IN5: &quot;); //显示字符串 while(1)&#123; //将光敏电阻的ADC数据显示在OLED上 OLED_DISPLAY_8x16(4,10*8,ADC_DMA_IN[0]/1000+0x30);// OLED_DISPLAY_8x16(4,11*8,ADC_DMA_IN[0]%1000/100+0x30);// OLED_DISPLAY_8x16(4,12*8,ADC_DMA_IN[0]%100/10+0x30);// OLED_DISPLAY_8x16(4,13*8,ADC_DMA_IN[0]%10+0x30);// OLED_DISPLAY_8x16(6,10*8,ADC_DMA_IN[1]/1000+0x30);// OLED_DISPLAY_8x16(6,11*8,ADC_DMA_IN[1]%1000/100+0x30);// OLED_DISPLAY_8x16(6,12*8,ADC_DMA_IN[1]%100/10+0x30);// OLED_DISPLAY_8x16(6,13*8,ADC_DMA_IN[1]%10+0x30);// delay_ms(500); //延时 &#125;&#125;","categories":[],"tags":[{"name":"STM32","slug":"STM32","permalink":"http://yoursite.com/tags/STM32/"}]},{"title":"Java项目安卓编程UI设计总结","slug":"Java项目安卓编程UI设计总结","date":"2019-02-23T17:20:00.000Z","updated":"2019-02-23T17:39:13.076Z","comments":true,"path":"2019/02/24/Java项目安卓编程UI设计总结/","link":"","permalink":"http://yoursite.com/2019/02/24/Java项目安卓编程UI设计总结/","excerpt":"今天是周六，本不该上班的，但是之前的项目没有完成，只能加班来搞，自己学JAVA比较少，更别说UI设计了，没有审美。。。 这次的UI自我感觉良好（-_-）,不过确实自己研究了好久才做出来的。在下面记录下编程的资料和代码，防止过一段儿忘了。","text":"今天是周六，本不该上班的，但是之前的项目没有完成，只能加班来搞，自己学JAVA比较少，更别说UI设计了，没有审美。。。 这次的UI自我感觉良好（-_-）,不过确实自己研究了好久才做出来的。在下面记录下编程的资料和代码，防止过一段儿忘了。 布局的控制，一般采用线性布局，绝对不能把布局写死，可以写成比例布局。 背景渐变色与圆角，圆角相对简单，但是渐变色自己要研究一下。 还有中空的外框布局待学习。 以及QMUI框架的使用并不简单，还得学习研究。 代码总结： 修改包名： 修改软件图标： 渐变色背景代码： 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; &gt; &lt;gradient android:angle=&quot;270&quot; android:centerColor=&quot;#00FFFF&quot; android:centerX=&quot;0.5&quot; android:centerY=&quot;0.5&quot; android:endColor=&quot;#666666&quot; android:startColor=&quot;#0099FF&quot; /&gt; &lt;padding android:bottom=&quot;7dp&quot; android:left=&quot;7dp&quot; android:right=&quot;7dp&quot; android:top=&quot;7dp&quot; /&gt; &lt;corners android:radius=&quot;4dp&quot; /&gt;&lt;/shape&gt; 边框背景： 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;solid android:color=&quot;#00000000&quot; /&gt; &lt;stroke android:width=&quot;3dp&quot; android:color=&quot;#065e8d&quot; /&gt; &lt;padding android:bottom=&quot;1dp&quot; android:left=&quot;1dp&quot; android:right=&quot;1dp&quot; android:top=&quot;1dp&quot; /&gt; &lt;corners android:radius=&quot;4dp&quot; /&gt;&lt;/shape&gt; 侧滑窗体背景： 123456789101112131415&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:shape=&quot;rectangle&quot;&gt; &lt;gradient android:angle=&quot;135&quot; android:centerColor=&quot;#009688&quot; android:endColor=&quot;#00695C&quot; android:startColor=&quot;#4DB6AC&quot; android:type=&quot;linear&quot; /&gt; &lt;padding android:bottom=&quot;7dp&quot; android:left=&quot;7dp&quot; android:right=&quot;7dp&quot; android:top=&quot;7dp&quot; /&gt; &lt;corners android:radius=&quot;4dp&quot; /&gt;&lt;/shape&gt; OK！今天先总结到这里，太困了，睁不开眼了。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Arduino+WZ指令+Onenet","slug":"Arduino+WZ指令+Onenet","date":"2019-02-23T16:53:00.000Z","updated":"2019-02-23T16:55:33.960Z","comments":true,"path":"2019/02/24/Arduino+WZ指令+Onenet/","link":"","permalink":"http://yoursite.com/2019/02/24/Arduino+WZ指令+Onenet/","excerpt":"视频演示： 这个小项目看似简单却费了很大劲才做出来。同时也解决了很多遇到的问题。","text":"视频演示： 这个小项目看似简单却费了很大劲才做出来。同时也解决了很多遇到的问题。 首先最严重的事情就是Arduino对应的OLED12864库的内存问题，国外开发者开发了很多的依赖库，但是U8g2这个库对内存要求比较高，所以导致了，刷入程序，直接内存爆满！达到94%，进而导致了Arduino开机无法运行，直接无限重启。解决方法：用老版本U8X8库。 其次是WZ指令3.0版本更新至3.1版本，因为前者没有做数据回传的优化，导致数据接收出现了内存阻塞问题。 总之这次也算是完成了这个小项目，以后就不搞了，想利用时间多学习。","categories":[],"tags":[{"name":"Onenet","slug":"Onenet","permalink":"http://yoursite.com/tags/Onenet/"}]},{"title":"QQ群开发板日常抽奖","slug":"QQ群开发板日常抽奖","date":"2019-02-20T15:53:00.000Z","updated":"2019-02-23T16:19:57.750Z","comments":true,"path":"2019/02/20/QQ群开发板日常抽奖/","link":"","permalink":"http://yoursite.com/2019/02/20/QQ群开发板日常抽奖/","excerpt":"从建QQ群以来，陆陆续续已经有300+的朋友加群，虽然大家有时候活跃人数并不多，但是内心满满的成就感！希望和大家一起学习，共同进步！ 特进行一次开发板抽奖赠送活动，板子是机智云开发板V3.0，之前申请的，一直没有时间玩，送给需要而且幸运的朋友。 抽奖规则 微信小程序公平抽奖，参与抽奖人数达到20人，自动开奖！注：参与抽奖者，需在博客下方留言，（建议用电脑打开）内容随意，若开奖时，中奖者未留言，取消资格，进行下一轮。 抽奖方式–》点击展开全文！微信扫一扫直达！","text":"从建QQ群以来，陆陆续续已经有300+的朋友加群，虽然大家有时候活跃人数并不多，但是内心满满的成就感！希望和大家一起学习，共同进步！ 特进行一次开发板抽奖赠送活动，板子是机智云开发板V3.0，之前申请的，一直没有时间玩，送给需要而且幸运的朋友。 抽奖规则 微信小程序公平抽奖，参与抽奖人数达到20人，自动开奖！注：参与抽奖者，需在博客下方留言，（建议用电脑打开）内容随意，若开奖时，中奖者未留言，取消资格，进行下一轮。 抽奖方式–》点击展开全文！微信扫一扫直达！","categories":[],"tags":[{"name":"抽奖","slug":"抽奖","permalink":"http://yoursite.com/tags/抽奖/"}]},{"title":"多种模组使用MQTT协议总结","slug":"多种模组使用MQTT协议总结","date":"2019-02-19T05:45:00.000Z","updated":"2019-04-11T07:46:20.335Z","comments":true,"path":"2019/02/19/多种模组使用MQTT协议总结/","link":"","permalink":"http://yoursite.com/2019/02/19/多种模组使用MQTT协议总结/","excerpt":"前言： 由于公司搭建的物联网IOT平台是基于MQTT协议的，再加上我们的设备要支持各种类型的模组 WIFI模组 （使用的是最常见的安信可模组） 4G模组（采用微雪SIM7600CE模组） NB-IOT模组（采用高新兴物联模组ME3616） &gt; 遇到的问题： 首先是COAP协议的兼容问题，我们一开始就想采用NB模组，COAP协议，毕竟现在比较火，但是，测试的效果并不是太好，尤其是山东有人物联网平台的模组，他们的COAP协议不支持自己搭建的服务器，这一点整个不符合我的路线，后来有采用了微雪的NB模组，发现他的COAP也是不太完善。首先是COAP协议的兼容问题，我们一开始就想采用NB模组，COAP协议，毕竟现在比较火，但是，测试的效果并不是太好，尤其是山东有人物联网平台的模组，他们的COAP协议不支持自己搭建的服务器，这一点整个不符合我的路线，后来有采用了微雪的NB模组，发现他的COAP也是不太完善。 其次是MQTT服务器的搭建，由于他的普适性，其服务器的搭建也相对简单。 后来我们采用了兼容性更高的MQTT协议，这个协议使用比较普遍，所以相对来说用起来比较简单，尤其是WIFI模组来对接MQTT协议，很简单就能做出来产品，同时我们又对其他类型的通讯模组进行了选型，最终找到了适合MQTT协议的模组，而且，运行起来相对稳定，比如高新兴物联作为主控的NB模组，我们已经将其安装在设备上运行。 MQTT协议的安卓开发，安卓针对MQTT协议有一定的固件包可以直接使用，所以这也是很快就可以搞定了的。 &gt; 下面是调试各种模组的AT指令笔记:","text":"前言： 由于公司搭建的物联网IOT平台是基于MQTT协议的，再加上我们的设备要支持各种类型的模组 WIFI模组 （使用的是最常见的安信可模组） 4G模组（采用微雪SIM7600CE模组） NB-IOT模组（采用高新兴物联模组ME3616） &gt; 遇到的问题： 首先是COAP协议的兼容问题，我们一开始就想采用NB模组，COAP协议，毕竟现在比较火，但是，测试的效果并不是太好，尤其是山东有人物联网平台的模组，他们的COAP协议不支持自己搭建的服务器，这一点整个不符合我的路线，后来有采用了微雪的NB模组，发现他的COAP也是不太完善。首先是COAP协议的兼容问题，我们一开始就想采用NB模组，COAP协议，毕竟现在比较火，但是，测试的效果并不是太好，尤其是山东有人物联网平台的模组，他们的COAP协议不支持自己搭建的服务器，这一点整个不符合我的路线，后来有采用了微雪的NB模组，发现他的COAP也是不太完善。 其次是MQTT服务器的搭建，由于他的普适性，其服务器的搭建也相对简单。 后来我们采用了兼容性更高的MQTT协议，这个协议使用比较普遍，所以相对来说用起来比较简单，尤其是WIFI模组来对接MQTT协议，很简单就能做出来产品，同时我们又对其他类型的通讯模组进行了选型，最终找到了适合MQTT协议的模组，而且，运行起来相对稳定，比如高新兴物联作为主控的NB模组，我们已经将其安装在设备上运行。 MQTT协议的安卓开发，安卓针对MQTT协议有一定的固件包可以直接使用，所以这也是很快就可以搞定了的。 &gt; 下面是调试各种模组的AT指令笔记: 首先是微雪的4G模组SIM7600CE 这里必须要吐槽一下，官方给的文档都是错误的，好多地方都错了网站：http://www.simcom.com/product/showproduct.php?lang=cn&amp;id=48微雪网址：http://www.waveshare.net/wiki/SIM7600CE_4G_HATMQTT说明（很多错误）：http://www.waveshare.net/w/upload/6/65/SIM7500_SIM7600_Series_MQTT_ATC_V1.01.pdf 指令 功能 AT+CRESET 模组复位 AT+CMQTTSTART 开始连接MQTT AT+CMQTTACCQ=0,”client c” 设置id AT+CMQTTCONNECT=0,”tcp://60.205.203.64”,60,1,”root”,”citc2018” 连接服务器（默认1883端口） AT+CMQTTTOPIC=0,5 设置主题（后面直接发字符，长度要对应） AT+CMQTTPAYLOAD=0,5 设置消息内容（后面直接发字符，长度要对应 AT+CMQTTPUB=0,1,60 发布消息 AT+CMQTTDISC=0, 120 断开连接 高新兴物联ME3616模组 买的是开发板，骑士电子的高配版，带GPS 指令 功能 AT+ZRST 模组复位 AT+ZCONTLED=1 打开指示灯（默认关闭） at+ipr=9600 串口波特率设置 AT+EMQNEW=”47.105.157.158”,”1883”,12000,100 设置域名 AT+EMQCON=0,3,”wenzheng”,60000,1,0,”root”,”citc2018” 连接MQTT AT+EMQSUB=0,”qishiNB”,1 订阅主题 AT+EMQPUB=0,”qishiNB”,1,0,0,4,”31323334” 发布消息（消息类型为ASCII码） GPS指令集 指令 功能 AT+ZGRUN=0 停止定位 AT+ZGRUN=1 启动单次定位 AT+ZGRUN=2 启动跟踪定位 移动M5311 MQTT 指令 功能 AT+IPR=9600 设置波特率 AT+CMSYSCTRL=0,2 打开指示灯 AT+CSQ 信号质量 AT+MQTTCFG=”域名”,1883,”zyNBiot”,120,”75829”,”IIOu0oFUg1guk20ornTK1uzAcnM=”,1 MQTT配置 AT+MQTTOPEN=1,1,1,1,1,”mywill”,”001bye” 连接MQTT AT+MQTTPUB=”device/nb/citc”,1,1,0,0,”hello” 发布消息 HTTP 指令 功能 AT+HTTPCREATE=”http://47.105.157.158:9094/“ 设置HTTP AT+HTTPHEADER=0,”User-Agent: Unkown\\r\\nConnection: close\\r\\n” 设置协议头 AT+HTTPSEND=0,1,”/topic/123” 发送post请求 AT+HTTPCLOSE=0 关闭HTTP","categories":[],"tags":[{"name":"工作总结","slug":"工作总结","permalink":"http://yoursite.com/tags/工作总结/"}]},{"title":"基于MQTT协议的WZ指令开发V3.0版本支持onenet","slug":"基于MQTT协议的WZ指令开发V3.0版本支持onenet","date":"2019-02-18T02:53:00.000Z","updated":"2019-02-23T16:21:36.080Z","comments":true,"path":"2019/02/18/基于MQTT协议的WZ指令开发V3.0版本支持onenet/","link":"","permalink":"http://yoursite.com/2019/02/18/基于MQTT协议的WZ指令开发V3.0版本支持onenet/","excerpt":"视频讲解：（V3.0版本）—https://www.bilibili.com/video/av44025282/ 视频讲解:(V2.0版本) —https://www.bilibili.com/video/av43813291/ ** 用法：单片机主循环里无脑循环发一条串口指令即可，什么都不需要配置！只有一条串口AT指令！**","text":"视频讲解：（V3.0版本）—https://www.bilibili.com/video/av44025282/ 视频讲解:(V2.0版本) —https://www.bilibili.com/video/av43813291/ ** 用法：单片机主循环里无脑循环发一条串口指令即可，什么都不需要配置！只有一条串口AT指令！** 昨天晚上我又更新了WZ指令至V3.0，以至于其可以兼容onenet服务器，而不需要添加其他的指令依旧是发送一条串口json字符串即可： 【V3.0】 1&#123;&quot;wz&quot;:&quot;wenzheng.club&quot;,&quot;id&quot;:&quot;517254399&quot;,&quot;port&quot;:&quot;6002&quot;,&quot;server&quot;:&quot;mqtt.heclouds.com&quot;,&quot;user&quot;:&quot;212737&quot;,&quot;password&quot;:&quot;eL2ObaFLA1UvjAfxjCBcUYKjxtY=&quot;,&quot;topic&amp;msg&quot;:&quot;&#123;\\&quot;wendu\\&quot;:\\&quot;14\\&quot;,\\&quot;shidu\\&quot;:\\&quot;66\\&quot;&#125;&quot;&#125; 【V2.0】 1&#123;&quot;wz&quot;:&quot;wenzheng.club&quot;,&quot;server&quot;:&quot;60.205.203.64&quot;,&quot;user&quot;:&quot;admin1&quot;,&quot;password&quot;:&quot;public&quot;,&quot;topic&quot;:&quot;20190213134505&quot;,&quot;message&quot;:&quot;test2019&quot;&#125; 之前2.0 版本已经讲解过如何使用此指令：就是通过单片机串口进行发送即可，注意双引号的转义与末尾的换行符：STM32串口发送举例： 1printf(&quot;&#123;\\&quot;wz\\&quot;:\\&quot;wenzheng.club\\&quot;,\\&quot;server\\&quot;:\\&quot;60.205.203.64\\&quot;,\\&quot;user\\&quot;:\\&quot;root\\&quot;,\\&quot;password\\&quot;:\\&quot;citc2018\\&quot;,\\&quot;topic\\&quot;:\\&quot;ZX10403001010000\\&quot;,\\&quot;message\\&quot;:\\&quot;T:226;H:232;\\&quot;&#125;&quot;); 指令说明： 根据onenet官方MQTT资料可知 则WZ指令的json说明，就一目了然了：（键值对无顺序要求） 键 值 是否必要 说明 wz wenzheng.club 是 此字段为WZ指令的鉴权码，必须传入，否则无法使用 server mqtt.heclouds.com 是 此字段为mqtt服务器的域名 id 517254399 否 此字段onenet必要设备ID，自建服务器可选（不选择默认上传esp地址码） port 6002 否 此字段onenet必要服务器端口，其他服务器默认1883端口 user 212737 是 此字段为用户名，onenet为产品ID，其他服务器用户可自定义 password eL2ObaFLA1UvjAfxjCBcUYKjxtY= 是 此字段为密码，onenet为apikey，其他服务器用户可以自定义 topic ZX10403001010000 否 若非onenet服务器，则此字段必要！为要发布的主题。 message test2019 否 若非onenet服务器，则此字段必要！为要发布的对应主题的消息 topic&amp;msg {\\”wendu\\”:\\”14\\”,\\”shidu\\”:\\”66\\”}”} 否 若为onenet服务器此字段必要！注：此字段为json里面套了一个json，所以“”wendu”与“shidu”就是在onenet上面设置的数据点，单片机在后面添加数值即可！ 更新日志：2019年2月18日午夜更新V3.0版本 支持onenet平台2019年2月13日晚上制作V2.0版本 添加mqtt_user验证 添加mqtt_passward验证2019年2月13日上午制作V1.0版本 实现基本通讯2019年初有初步想法 配网问题：为了更好地用户体验，不需要单片机进行AT指令配网，只需要在刷好固件以后，通过微信，或者安卓APP进行配置即可，一次配置，永久掉电存储，而且上电自动联网！等待单片机发送串口指令。如果到了新的wifi环境，10秒内连接网络失败，自动进入智能配网模式。 OK！总的来说，V3.0是兼容V2.0的协议的，只是多加了几个字段用于onenet服务器！同时，针对onenet服务器作了topic和message的整合，这样可以一次传多个数据点。 缺点：采用了json包json的方式，这里用户体验或者数据封包可能不是太好，后续我会优化，或者写一个适用于单片机的函数。有意见和建议欢迎留言QQ群：476840321，下一版本计划更新百度云平台，一行代码发送数据。","categories":[],"tags":[{"name":"WZ指令","slug":"WZ指令","permalink":"http://yoursite.com/tags/WZ指令/"}]},{"title":"基于MQTT协议的WZ指令开发","slug":"基于MQTT协议的WZ指令开发","date":"2019-02-14T15:50:00.000Z","updated":"2019-02-14T15:39:59.734Z","comments":true,"path":"2019/02/14/基于MQTT协议的WZ指令开发/","link":"","permalink":"http://yoursite.com/2019/02/14/基于MQTT协议的WZ指令开发/","excerpt":"这是一款真正的基于MQTT的AT指令 基于MQTT协议的MCU通讯指令-WZ指令2.0版本已完结，可用于STM32的数据发送。名称：基于MQTT的万能AT指令（名称来源于本人名字故取名为WZ指令）特点： 简单到只需要一行代码就可以将数据点推送至MQTT服务器 可用于个人EMQ服务器，或者树莓派搭建的局域网服务器（暂不支持onenet等商用平台）默认端口：1883同时支持微信配网、安卓APP配网，支持掉电存储、支持用户名密码校验、 支持wifi掉线重连、支持服务器掉线重连。版本号：V2.0作者：阿正网站：wenzheng.club固件可以加群下载：476840321","text":"这是一款真正的基于MQTT的AT指令 基于MQTT协议的MCU通讯指令-WZ指令2.0版本已完结，可用于STM32的数据发送。名称：基于MQTT的万能AT指令（名称来源于本人名字故取名为WZ指令）特点： 简单到只需要一行代码就可以将数据点推送至MQTT服务器 可用于个人EMQ服务器，或者树莓派搭建的局域网服务器（暂不支持onenet等商用平台）默认端口：1883同时支持微信配网、安卓APP配网，支持掉电存储、支持用户名密码校验、 支持wifi掉线重连、支持服务器掉线重连。版本号：V2.0作者：阿正网站：wenzheng.club固件可以加群下载：476840321 目前市面上能找到的兼容MQTT的AT指令少之又少 而且安信可和乐鑫官方也没有开发这个AT指令，基本上都是基于MCU端的处理，同时MQTT是基于TCP转化而来， 如果想要用MQTT就把TCP数据封包成为MQTT协议，就可以用TCP发出MQTT的数据。 &gt; 这是arduino中文社区的一篇帖子，感觉讲的非常好https://www.arduino.cn/thread-82851-1-1.html 我的方法，与上面的方法不同，我是从用户端的逻辑来进行的操作，以至于达到了很好的用户体验！ 最终效果： 使用说明： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849****************************名称：基于MQTT的万能AT指令（名称来源于本人名字故取名为WZ指令）特点： 简单到只需要一行代码就可以将数据点推送至MQTT服务器 可用于个人EMQ服务器，或者树莓派搭建的局域网服务器（暂不支持onenet等商用平台） 默认端口：1883 同时支持微信配网、安卓APP配网，支持掉电存储、支持用户名密码校验、 支持wifi掉线重连、支持服务器掉线重连。版本号：V2.0作者：阿正网站：wenzheng.club*****************************烧写位置：0x00000000建议将ESP01清除缓存后再烧写配网：微信智能配网（或者安卓APP配网），可掉电存储，不需要AT指令单独配置。 AT指令：仅此一条json数据，没有繁琐的其他配置环节，简单粗暴 &#123;&quot;wz&quot;:&quot;wenzheng.club&quot;,&quot;server&quot;:&quot;60.205.203.64&quot;,&quot;user&quot;:&quot;admin1&quot;,&quot;password&quot;:&quot;public&quot;,&quot;topic&quot;:&quot;20190213134505&quot;,&quot;message&quot;:&quot;test2019&quot;&#125;AT指令说明： 1、&quot;wz&quot;:&quot;wenzheng.club&quot; 为必填项！无此字段无法使用此指令。 2、服务器连接：第一次发送这条AT指令时会进行服务器连接， 3、消息发布：后续发送这条AT指令则代表发送指定主题的消息。message目前最大支持200字节。 3、主题订阅：目前暂不支持用户自定义订阅主题， 但是系统开机默认订阅主题名为：wz_server 的主题！ 4、消息接收：wz_server 发布的消息会在串口中打印出来， 如：WZ:[Hello world!] 用户可对此进行处理然后执行相关动作。 后续版本会支持用户自定义。 代码举例： **arduino** void setup() &#123;Serial.begin(9600);&#125;void loop() &#123; Serial.println(&#123;\\&quot;wz\\&quot;:\\&quot;wenzheng.club\\&quot;,\\&quot;server\\&quot;:\\&quot;60.205.203.64\\&quot;,\\&quot;user\\&quot;:\\&quot;root\\&quot;,\\&quot;password\\&quot;:\\&quot;citc2018\\&quot;,\\&quot;topic\\&quot;:\\&quot;ZX1040300101000\\&quot;,\\&quot;message\\&quot;:\\&quot;T:226;H:232;\\&quot;&#125;&quot;); //真正的只需要一行代码实现数据发送！！用户只需要拼接字符即可！ delay(1000);&#125;**STM32**单片机配置好串口直接printf(&quot;&#123;\\&quot;wz\\&quot;:\\&quot;wenzheng.club\\&quot;,\\&quot;server\\&quot;:\\&quot;60.205.203.64\\&quot;,\\&quot;user\\&quot;:\\&quot;root\\&quot;,\\&quot;password\\&quot;:\\&quot;citc2018\\&quot;,\\&quot;topic\\&quot;:\\&quot;ZX10403001010000\\&quot;,\\&quot;message\\&quot;:\\&quot;T:226;H:232;\\&quot;&#125;&quot;);即可！///**************///更新日志：2019年2月13日晚上制作V2.0版本 添加mqtt_user验证 添加mqtt_passward验证2019年2月13日上午制作V1.0版本 实现基本通讯2019年初有初步想法 STM32串口测试： 总结，经过我的测试，还是相对稳定的，无论是Arduino还是STM32进行数据发送，都是可以的。经测试Arduino不间断发送3000+数据，服务器接收依然正常！","categories":[],"tags":[{"name":"WZ指令","slug":"WZ指令","permalink":"http://yoursite.com/tags/WZ指令/"}]},{"title":"2019博客再次更新评论系统","slug":"2019博客再次更新评论系统","date":"2019-02-12T13:25:00.000Z","updated":"2019-02-12T13:36:51.465Z","comments":true,"path":"2019/02/12/2019博客再次更新评论系统/","link":"","permalink":"http://yoursite.com/2019/02/12/2019博客再次更新评论系统/","excerpt":"又是激动人心的时刻，在2019年我的博客又更新了评论插件！一款完美适配HEXO的评论插件！我的个人博客– http://wenzheng.clubValine插件。搭配leancloud食用更佳哦！ My blog has been updated again 可以试下在下面评论哦！↓↓↓","text":"又是激动人心的时刻，在2019年我的博客又更新了评论插件！一款完美适配HEXO的评论插件！我的个人博客– http://wenzheng.clubValine插件。搭配leancloud食用更佳哦！ My blog has been updated again 可以试下在下面评论哦！↓↓↓ 可以试下在下面评论哦！↓↓↓","categories":[],"tags":[{"name":"评论系统","slug":"评论系统","permalink":"http://yoursite.com/tags/评论系统/"}]},{"title":"我的安卓项目总结","slug":"我的安卓项目总结","date":"2019-02-12T12:53:00.000Z","updated":"2019-02-12T13:18:55.280Z","comments":true,"path":"2019/02/12/我的安卓项目总结/","link":"","permalink":"http://yoursite.com/2019/02/12/我的安卓项目总结/","excerpt":"先来波图集 软件的用途：其实是公司膜项目需求，我作为一个硬件开发者，只是来做一个DEMO，不过从中真正的学到了很多东西，非常开心。","text":"先来波图集 软件的用途：其实是公司膜项目需求，我作为一个硬件开发者，只是来做一个DEMO，不过从中真正的学到了很多东西，非常开心。 这是我安卓物联网项目的完结版本，真正的java编程。 集成了MQTT通讯 ESP智能配网 蒲公英远程更新 蒲公英bug提交与反馈 bmob数据库 volley框架 这次的安卓开发，满满的收获，希望以后能开发出更多有意义的软件，来强大自己的力量，同时硬件部分还要加紧学习。2019！加油努力！","categories":[],"tags":[{"name":"Siri","slug":"Siri","permalink":"http://yoursite.com/tags/Siri/"}]},{"title":"年前STM32作品总结","slug":"年前STM32作品总结","date":"2019-01-30T02:53:00.000Z","updated":"2019-02-12T11:42:14.023Z","comments":true,"path":"2019/01/30/年前STM32作品总结/","link":"","permalink":"http://yoursite.com/2019/01/30/年前STM32作品总结/","excerpt":"最近做了一些项目包括公司和个人的 自己平时很少玩32项目，所以还是比较吃力的，但是也勉强完成了这个项目。 实际的运行效果","text":"最近做了一些项目包括公司和个人的 自己平时很少玩32项目，所以还是比较吃力的，但是也勉强完成了这个项目。 实际的运行效果 从这个作品里 我真的学到了很多知识，有关STM32作品的知识，其实这也算我人生中第一个真正意义上的STM32作品，因为我之前确实没玩过STM32，也没有做过相关的项目，到了公司以后才开始真正的接触STM32，而且一上来就是STM32F4的芯片，当时我一脸懵逼，又怕赶不上大家的步伐，所以我就抓紧时间学习了一下32的知识，看了一些教程，有的是视频教程买更多的还是看代码，拷贝粘贴，再修改。最终历时半个月，终于算是完成了这个作品。 项目来源：网上的朋友让我给他做毕业设计，收费的哦。 传感器选型：基本都是一些常用的传感器除了GSM模块（后来发现这玩意儿贼简单5行代码搞定） 遇到的瓶颈，作为一个初学者，还是遇到了很多问题的，比如我代码中注释的，例如IO方向的设置，模拟量的读取、I2C通讯协议的问题（不求甚解吧） 下面是main函数的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331#include &quot;led.h&quot;#include &quot;delay.h&quot;#include &quot;dht11.h&quot; //温湿度传感器库#include &quot;sys.h&quot;#include &quot;usart.h&quot;#include &quot;usart2.h&quot;#include &quot;OLED.h&quot;#include &quot;ds1302.h&quot; //时钟模块库#include &quot;adc.h&quot; //ADC采样库#include &quot;motor.h&quot; //步进电机库#include &quot;key.h&quot;#include &quot;beep.h&quot;#include &quot;stmflash.h&quot;#include &quot;iic.h&quot; //I2C库 用于驱动光照传感器#include &quot;BH1750.h&quot; //光照传感器库#define FLASH_SAVE_ADDR 0X0800fe00 //设置FLASH 保存地址(必须为偶数，且其值要大于本代码所占用FLASH的大小+0X08000000)//本代码由 阿正整理（部分原创） //B站视频链接： https://www.bilibili.com/video/av41993140///本人小白 很少玩 STM32 这是第一个STM32作品，代码过于粗糙 也没时间整理，大神勿喷。//转载请注明出处，欢迎加群一起学习;476840321u16 test_flash = 100;u16 data[1]=&#123;0&#125;; //要写入的数据uint8_t *bth_msg;u16 adcx,dlx,ch2o=0;u8 temperature=0; //温度 u8 humidity=0; //湿度u16 set_T = 10; //定时 小时u16 set_M = 10; //定时 分钟int oled_clrflag = 0,guang_set=80; //光照初始值int chuang_flag = 0;unsigned char cc[10] = &quot;AT\\r\\n&quot;;unsigned char hh[20] = &quot;AT+CMGF=1\\r\\n&quot;;unsigned char gsm[20] = &quot;AT+CSCS=\\&quot;GSM\\&quot;\\r\\n&quot;;unsigned char hm[40] = &quot;AT+CMGS=\\&quot;17739782188\\&quot;\\r\\n&quot;; //改成你的手机号unsigned char xx[10] = &quot;hello&quot;; //报警信息void DisInit();void read_flash();void HW_int();void seting_oled ();void send_GSM();void open_chuang();void close_chuang();void float_char(float f,unsigned char *s);unsigned char Dec2Asc(unsigned char input, char* output );typedef union //测试结构体&#123; float f; unsigned char u[10];&#125;Float4Byte; int main(void) &#123; unsigned char txd_data; unsigned int txd_databuffer; #if USESPI SPI1_Config(); DMA_SPI_Config(); #endif u8 t,time[15],len; Float4Byte m1; float test = 8.12; float temp; float datalx; u16 times=0; u8 DisFlag=0; //显示切换标志 int x ; int KEY2_flag = 0; SystemInit(); //配置系统时钟为 delay_init(); //延时函数初始化 NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); //设置中断优先级分组2 uart_init(9600); //主串口初始化为9600 usart2_init(9600); //串口2初始化9600 用于GSM通讯 LED_Init(); //初始化与LED连接的硬件接口 OLED_IOInit(); //OLEDIO初始化 OLED_Init(); //OLED初始化 Adc_Init(); //ADC初始化 A1 作为采集口 DHT11_Init(); //DHT11初始化 PC13 DS1302_Init(); //DS1302初始化 Motor_Init(); //步进电机初始化 HW_int(); //人体红外初始化 iic_init(); //i2c初始化 KEY_Init(); //按键初始化 Beep_Init(); //蜂鸣器初始化 bh_data_send(BHPowOn); bh_data_send(BHReset); bh_data_send(BHModeH2); delay_ms(10); //DS1302_Write_Time(); //初始化DS1302时间 时间不准确时，可以用它更新时间 DisInit(); //显示屏开机画面显示 delay_ms(1000); //延时单次不能延时大于1000 delay_ms(1000); //延时 OLED_Fill(0x00); //清屏 read_flash(); //读取flash数据 printf(&quot;\\r\\nflash存储的数据为:%d\\r\\n&quot;,test_flash); while(1) &#123; t=KEY_Scan(0); //得到键值 if(t!=0)&#123; Beep=1; delay_ms(100); Beep=0; &#125; //按键操作说明：在未进入设置页面情况下，上下按钮分别为开关窗，在进入设置页面后，上下按钮为设置阈值 if (t==KEY0_PRES)&#123; //+ if(DisFlag == 1)&#123; guang_set++; &#125;else if (DisFlag == 2)&#123; set_M++; if (set_M&gt;59)set_M =59; &#125; else&#123; open_chuang(); &#125; &#125; if (t==KEY1_PRES)&#123; //- if(DisFlag ==1) &#123; guang_set--; &#125;else if (DisFlag == 2)&#123; set_M--; if (set_M&lt;1)set_M =1; &#125; else&#123; close_chuang(); &#125; &#125; if (t==KEY2_PRES)&#123; //设置翻页按钮 KEY2_flag++; if (KEY2_flag&gt;2) KEY2_flag = 0; switch (KEY2_flag)&#123; case 0:&#123; DisFlag=0; &#125; break; case 1:&#123; DisFlag=1; oled_clrflag=1; &#125; break; case 2:&#123; DisFlag=2; oled_clrflag=1; &#125; break; &#125; &#125; DS1302_Get_Time(time); //获取时钟模块时间 DHT11_Read_Data(&amp;temperature,&amp;humidity); //读取温湿度值 adcx=Get_Adc_Average(ADC_Channel_1,10); //读取ADC采样 temp=(float)adcx*(3.3/4096); //转换为3.3V数据量 ch2o=temp*1000;//先放大便于处理 datalx = bh_data_read()/1.2; //获取光照强度 dlx = datalx*1; if(dlx&gt;99) dlx=99; if (dlx&gt;guang_set) //自动开窗 &#123; if (chuang_flag == 0)&#123; open_chuang(); &#125; &#125; if(time[11]*10+time[12] &gt; set_M) //到达定时时间执行动作 &#123; if (chuang_flag == 0)&#123; open_chuang(); &#125; &#125; x = GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_4); //读取红外状态 if (x &amp;&amp; (chuang_flag))&#123; //检测人体 printf(&quot;dangerous&quot;); Beep=1; send_GSM(); //发送报警短信信息。 &#125;else Beep=0;// printf(&quot;%d%d%d%d年%d%d月%d%d日 &quot;, time[0],time[1],time[2],time[3],time[4],time[5],time[6],time[7]);// printf(&quot;%d%d时%d%d分%d%d秒 星期%d\\n&quot;, time[9],time[10],time[11],time[12],time[13],time[14],time[8]); if (DisFlag == 0)&#123; //----------------------------------------// LCD_P16x16Ch(32,0,27); //&quot;环&quot; LCD_P16x16Ch(32+16,0,28); //&quot;境&quot; LCD_P16x16Ch(32+32,0,29); //&quot;检&quot; LCD_P16x16Ch(32+48,0,30); //&quot;测&quot; LCD_P16x16Ch(32+64,0,31); //&quot;仪&quot; //----------------------------------------// LCD_P16x16Ch(0,2,25); //&quot;烟雾&quot; LCD_P16x16Ch(16,2,26); LCD_8x16Ch(32,2,ch2o/100%10); LCD_8x16Ch(40,2,ch2o%100/10%10); LCD_8x16Ch(48,2,ch2o%10%10); //----------------------------------------// LCD_P16x16Ch(64,2,32); //&quot;光照&quot; LCD_P16x16Ch(80,2,33); OLED_P8x16Str(96,2,&quot;:&quot;); LCD_8x16Ch(104,2,dlx/10%10); LCD_8x16Ch(112,2,dlx%10); //----------------------------------------// //------------温度------------// LCD_P16x16Ch(0,4,0); //&quot;温&quot; LCD_P16x16Ch(16,4,1); //&quot;度&quot; OLED_P8x16Str(32,4,&quot;:&quot;); LCD_8x16Ch(40,4,temperature/10%10); LCD_8x16Ch(48,4,temperature%10); //------------湿度------------// LCD_P16x16Ch(66,4,2); //&quot;湿&quot; LCD_P16x16Ch(66+16,4,3); //&quot;度&quot; OLED_P8x16Str(66+32,4,&quot;:&quot;); LCD_8x16Ch(66+40,4,humidity/10%10); LCD_8x16Ch(66+48,4,humidity%10); //------------时间------------// LCD_P16x16Ch(0,6,23); //&quot;时&quot; LCD_P16x16Ch(16,6,24); //&quot;间&quot; OLED_P8x16Str(32,6,&quot;:&quot;); LCD_8x16Ch(48,6,time[9]); LCD_8x16Ch(56,6,time[10]); OLED_P8x16Str(64,6,&quot;:&quot;); LCD_8x16Ch(72,6,time[11]); LCD_8x16Ch(80,6,time[12]); &#125;else if (DisFlag ==1)&#123; if(oled_clrflag)&#123; OLED_Fill(0x00); oled_clrflag=0; &#125; LCD_P16x16Ch(16,0,32); //&quot;设置页面&quot; LCD_P16x16Ch(32,0,33); LCD_P16x16Ch(48,0,34); LCD_P16x16Ch(64,0,35); LCD_P16x16Ch(80,0,36); LCD_P16x16Ch(96,0,37); LCD_P16x16Ch(0,2,32); //&quot;光照&quot; LCD_P16x16Ch(16,2,33); OLED_P8x16Str(32,2,&quot;:&quot;); LCD_8x16Ch(40,2,guang_set/10%10); LCD_8x16Ch(48,2,guang_set%10); &#125;else if (DisFlag ==2)&#123; if(oled_clrflag)&#123; OLED_Fill(0x00); oled_clrflag=0; &#125; LCD_P16x16Ch(16,0,23); //&quot;设置页面&quot; LCD_P16x16Ch(32,0,24); LCD_P16x16Ch(48,0,34); LCD_P16x16Ch(64,0,35); LCD_P16x16Ch(80,0,36); LCD_P16x16Ch(96,0,37); LCD_P16x16Ch(0,2,23); //&quot;时间&quot; LCD_P16x16Ch(16,2,24); OLED_P8x16Str(32,2,&quot;:&quot;); LCD_8x16Ch(40,2,set_M/10%10); LCD_8x16Ch(48,2,set_M%10); &#125; delay_ms(100); test_flash = 200; data[0] = test_flash; STMFLASH_Write(FLASH_SAVE_ADDR,data,1); //测试缓存数据 &#125; &#125; void open_chuang() //开窗 &#123; Motorcw_angle(180,10); chuang_flag = 1; &#125; void close_chuang() //关窗 &#123; Motorse_angle(180,10); chuang_flag = 0; &#125;/*从flash读出保存的参数*/void read_flash()&#123; u16 data[1]=&#123;0&#125;; STMFLASH_Read(FLASH_SAVE_ADDR,data,1); if(data[0]==0xffff) return; //如果为空，直接返回。 //取数据 test_flash=data[0]; //yyFlag =data[1];&#125;void HW_int() //人体红外初始化&#123; GPIO_InitTypeDef GPIO_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);//使能PE端时钟 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4; // HWBZ--&gt;PE1 端口配置 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; //上拉输入 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; //IO口速度为50MHz GPIO_Init(GPIOA,&amp;GPIO_InitStructure); //根据参数设定初始化GPIOE1&#125;void DisInit()&#123; OLED_Fill(0x00); //初始清屏 OLED_P8x16Str(0,0,&quot;Hello my STM32&quot;); OLED_P8x16Str(10,2,&quot;2019 Come on!&quot;); OLED_P8x16Str(10,6,&quot;wenzheng.club&quot;);&#125;void send_GSM() //发送报警短信&#123;usart2_SendStringByLen(cc,sizeof(cc)); delay_ms(1000); usart2_SendStringByLen(hh,sizeof(hh)); delay_ms(1000); usart2_SendStringByLen(gsm,sizeof(gsm)); delay_ms(1000); usart2_SendStringByLen(hm,sizeof(hm)); delay_ms(1000); usart2_SendStringByLen(xx,sizeof(xx)); delay_ms(1000); USART2SendByte(0x1A); delay_ms(1000);&#125;//学习笔记：/*注意：SIM800L供电为5V供电。OLED显示的所有数据都是有位图组成的，且都存在于codetab.h中。//OLED_P8x16Str(0,2,&quot;ok&quot;); 第一个参数为横坐标，第二个参数为纵坐标。LCD_P16x16Ch(0,0,5); //中文字符取模存储在 codetab.h中LCD_8x16Ch(48+16,2,temperature/10%10); # 正点原子的代码单次延时不能超过1000 delay_ms(1000);欲显示浮点型数据，需要把数据拼接（乘以1000）为整型，再取余即可如： temp实际数值为1.700 u16 ch2o=0; adcx=Get_Adc_Average(ADC_Channel_1,10); temp=(float)adcx*(3.3/4096); temp= temp*1000; ch2o=temp; LCD_8x16Ch(48,0,ch2o/1000); OLED_P8x16Str(48+8,0,&quot;.&quot;); //m LCD_8x16Ch(48+16,0,ch2o%1000/100%10); LCD_8x16Ch(48+24,0,ch2o%1000%100/10%10); LCD_8x16Ch(48+32,0,ch2o%10); 下面是IO方向设置的代码**重要**#define IIC_SDA_OUT() &#123;GPIOC-&gt;CRH&amp;=0X0FFFFFFF;GPIOC-&gt;CRH|=0x30000000;&#125;//输入模式上拉下拉输入模式#define IIC_SDA_IN() &#123;GPIOC-&gt;CRH&amp;=0X0FFFFFFF;GPIOC-&gt;CRH|=0x80000000;&#125;//通用推挽输出50MZ*/ 具体的代码文件我已经上传到了群文件：阿正工作站476840321","categories":[],"tags":[{"name":"总结","slug":"总结","permalink":"http://yoursite.com/tags/总结/"}]},{"title":"2019生活","slug":"My 2019","date":"2019-01-15T02:53:00.000Z","updated":"2019-02-23T16:22:05.649Z","comments":true,"path":"2019/01/15/My 2019/","link":"","permalink":"http://yoursite.com/2019/01/15/My 2019/","excerpt":"","text":"My 2019 begin 2019开始了，今天我租了人生中第一个房子，借了朋友2500元，开始了我的郑漂生活，简单纯粹，生活如初。 现在依旧是每天熬夜到很久，看代码、写程序、现在最充实的就是每天下班依旧在学习，学东西。一边接单做一些小项目，同时又能学习很多东西，这种感觉很简单纯粹，虽然依旧是熬夜，但是没有压力，就是单纯的学习没我很喜欢。","categories":[],"tags":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/tags/生活/"}]},{"title":"深夜拜读感慨万千","slug":"深夜拜读感慨万千","date":"2019-01-04T16:19:00.000Z","updated":"2019-01-04T16:26:59.088Z","comments":true,"path":"2019/01/05/深夜拜读感慨万千/","link":"","permalink":"http://yoursite.com/2019/01/05/深夜拜读感慨万千/","excerpt":"","text":"深夜拜读，难以入眠 彭稚辉的博客我已经看了好几年了，一直将其作为我的指路明灯，每当自己松懈之时，就读一下他的博客，立刻就会充满斗志。每一次拜读，都有新的收获与激情。 感觉自己学的东西过于粗糙 一知半解，没有深入去学习某一项 总是急于求成，囫囵吞枣 基础不牢，地动山摇 希望自己2019年每个月自己也能做出一个项目，记录自己的点滴进步","categories":[],"tags":[{"name":"心语","slug":"心语","permalink":"http://yoursite.com/tags/心语/"}]},{"title":"基于MQTT物联网项目2.0","slug":"基于MQTT物联网项目2.0","date":"2019-01-01T12:10:00.000Z","updated":"2019-01-01T12:21:49.688Z","comments":true,"path":"2019/01/01/基于MQTT物联网项目2.0/","link":"","permalink":"http://yoursite.com/2019/01/01/基于MQTT物联网项目2.0/","excerpt":"基于MQTT物联网项目2.0","text":"基于MQTT物联网项目2.0 看下视频效果。 硬件采用ESP8266制作 软件由android studio 开发 耗时3天。 出售价格：800元 来一波臭长臭长的代码。。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514package myself.mqtt.wenzheng.studio.mqtt;import android.Manifest;import android.annotation.SuppressLint;import android.app.Notification;import android.app.NotificationManager;import android.content.Context;import android.content.Intent;import android.content.pm.PackageManager;import android.graphics.Color;import android.media.MediaRecorder;import android.net.wifi.WifiInfo;import android.net.wifi.WifiManager;import android.os.Build;import android.os.Bundle;import android.os.Environment;import android.os.Handler;import android.os.IBinder;import android.os.Message;import android.support.annotation.NonNull;import android.support.design.widget.FloatingActionButton;import android.support.design.widget.Snackbar;import android.support.v4.app.ActivityCompat;import android.support.v4.app.NotificationCompat;import android.telephony.TelephonyManager;import android.util.Log;import android.view.KeyEvent;import android.view.MotionEvent;import android.view.View;import android.support.design.widget.NavigationView;import android.support.v4.view.GravityCompat;import android.support.v4.widget.DrawerLayout;import android.support.v7.app.ActionBarDrawerToggle;import android.support.v7.app.AppCompatActivity;import android.support.v7.widget.Toolbar;import android.view.Menu;import android.view.MenuItem;import android.webkit.WebSettings;import android.webkit.WebView;import android.webkit.WebViewClient;import android.widget.Button;import android.widget.CompoundButton;import android.widget.EditText;import android.widget.RemoteViews;import android.widget.Switch;import android.widget.TextView;import android.widget.Toast;import com.android.volley.AuthFailureError;import com.android.volley.Request;import com.android.volley.RequestQueue;import com.android.volley.Response;import com.android.volley.VolleyError;import com.android.volley.toolbox.StringRequest;import com.android.volley.toolbox.Volley;import com.mylhyl.acp.Acp;import com.mylhyl.acp.AcpListener;import com.mylhyl.acp.AcpOptions;import org.eclipse.paho.client.mqttv3.IMqttDeliveryToken;import org.eclipse.paho.client.mqttv3.MqttCallback;import org.eclipse.paho.client.mqttv3.MqttClient;import org.eclipse.paho.client.mqttv3.MqttConnectOptions;import org.eclipse.paho.client.mqttv3.MqttException;import org.eclipse.paho.client.mqttv3.MqttMessage;import org.eclipse.paho.client.mqttv3.persist.MemoryPersistence;import org.feezu.liuli.timeselector.TimeSelector;import org.json.JSONObject;import java.io.BufferedReader;import java.io.DataOutputStream;import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.net.HttpURLConnection;import java.net.URL;import java.text.SimpleDateFormat;import java.util.Date;import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.concurrent.Executors;import java.util.concurrent.ScheduledExecutorService;import java.util.concurrent.TimeUnit;import java.util.regex.Matcher;import java.util.regex.Pattern;import cn.bmob.v3.Bmob;import cn.bmob.v3.BmobObject;import org.feezu.liuli.timeselector.TimeSelector;import cn.bmob.v3.BmobQuery;import cn.bmob.v3.exception.BmobException;import cn.bmob.v3.listener.QueryListener;import cn.bmob.v3.listener.SaveListener;import cn.bmob.v3.listener.UpdateListener;public class MainActivity extends AppCompatActivity implements NavigationView.OnNavigationItemSelectedListener &#123; //程序初始化 private String host = &quot;tcp://60.205.203.64:1883&quot;; //private String host = &quot;tcp://clouddata.usr.cn:1883&quot;; //private String userName = &quot;wenzheng&quot;; //private String passWord = &quot;qqwan521&quot;; private String userName = &quot;admin&quot;; private String passWord = &quot;public&quot;; private String messagg_val ; private TextView t_time; private String p ; private String m ; private int i = 1; private Handler handler; private MqttClient client; private String timeTopic = &quot;sensor/time&quot;; private String wendu_Topic = &quot;sensor/temperature_celsius&quot;; private String shidu_Topic = &quot;sensor/humidity&quot;; private String shuiwei_Topic = &quot;sensor/water&quot;; private String work_topic = &quot;sensor/work&quot;; private MqttConnectOptions options; private ScheduledExecutorService scheduler; private TextView wendu; private TextView shidu; private TextView shuixiang; private TextView text_nowtime; private Button send_time; private Switch sw1; private Switch sw2; private Switch sw3; private Object IMEI; @Override protected void onCreate(Bundle savedInstanceState) &#123; //程序启动操作 super.onCreate(savedInstanceState); init(); //MQTT初始化 //bmob初始化 Bmob.initialize(this, &quot;c7bb112efe55d1f43973476f5e83c6ce&quot;); setContentView(R.layout.activity_main); /////////////////////////////////////////////////////// Acp.getInstance(this).request(new AcpOptions.Builder() .setPermissions(Manifest.permission.WRITE_EXTERNAL_STORAGE, Manifest.permission.READ_PHONE_STATE, Manifest.permission.SEND_SMS) .setDeniedMessage(&quot;测试&quot;) // .setDeniedCloseBtn() // .setDeniedSettingBtn() .setRationalMessage(&quot;6666&quot;) // .setRationalBtn() .build(), new AcpListener() &#123; @Override public void onGranted() &#123; //授权成功的效果 &#125; @Override public void onDenied(List&lt;String&gt; permissions) &#123; makeText(permissions.toString() + &quot;权限拒绝&quot;); &#125; &#125;); /////////////////////////////////////////////////////// Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar); setSupportActionBar(toolbar); FloatingActionButton fab = (FloatingActionButton) findViewById(R.id.fab); fab.setOnTouchListener(new View.OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; if(event.getAction() == MotionEvent.ACTION_DOWN)&#123; Toast.makeText(MainActivity.this,&quot;按下了&quot; ,Toast.LENGTH_SHORT).show(); // startRecord(); &#125;else if(event.getAction() == MotionEvent.ACTION_UP)&#123; Toast.makeText(MainActivity.this,&quot;松开了&quot; ,Toast.LENGTH_SHORT).show(); // stopRecord(); &#125; return true; //消耗掉当前事件 &#125; &#125;); DrawerLayout drawer = (DrawerLayout) findViewById(R.id.drawer_layout); ActionBarDrawerToggle toggle = new ActionBarDrawerToggle( this, drawer, toolbar, R.string.navigation_drawer_open, R.string.navigation_drawer_close); drawer.addDrawerListener(toggle); toggle.syncState(); NavigationView navigationView = (NavigationView) findViewById(R.id.nav_view); navigationView.setNavigationItemSelectedListener(this); handler = new Handler()&#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); upda_time(); if (msg.what == 1) &#123; //收到消息 并更新UI messagg_val = (String) msg.obj; // Toast.makeText(MainActivity.this, (String) msg.obj, Toast.LENGTH_SHORT).show(); if (messagg_val.indexOf(&quot;temperature_celsius&quot;)!= -1) &#123; String regEx=&quot;[^0-9.]&quot;; //正则表达式 Pattern p = Pattern.compile(regEx); Matcher m = p.matcher(messagg_val); wendu.setText(m.replaceAll(&quot;&quot;).trim()); &#125;else if (messagg_val.indexOf(&quot;humidity&quot;)!= -1) &#123; String regEx=&quot;[^0-9.]&quot;; //正则表达式 Pattern p = Pattern.compile(regEx); Matcher m = p.matcher(messagg_val); shidu.setText(m.replaceAll(&quot;&quot;).trim()); &#125;else if (messagg_val.indexOf(&quot;water&quot;)!= -1) &#123; String regEx=&quot;[^0-9.]&quot;; //正则表达式 Pattern p = Pattern.compile(regEx); Matcher m = p.matcher(messagg_val); shuixiang.setText(m.replaceAll(&quot;&quot;).trim()); &#125; &#125; else if (msg.what == 2) &#123; System.out.println(&quot;连接成功&quot;); Toast.makeText(MainActivity.this, &quot;连接成功&quot;, Toast.LENGTH_SHORT).show(); try &#123; client.subscribe(timeTopic, 1);//订阅主题“mytopic” client.subscribe(wendu_Topic,1);//订阅主题“wendu_Topic” client.subscribe(shidu_Topic, 1);//订阅主题“shidu_Topic” client.subscribe(shuiwei_Topic, 1);//订阅主题“shuiwei_Topic” &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; else if (msg.what == 3) &#123; Toast.makeText(MainActivity.this, &quot;连接失败，系统正在重连&quot;, Toast.LENGTH_SHORT).show(); System.out.println(&quot;连接失败，系统正在重连&quot;); &#125; &#125; private void upda_time() &#123; Date date = new Date(); SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm&quot;); String format1 = format.format(date); text_nowtime.setText(format1); &#125; &#125;; //获取wifi服务 @SuppressLint(&quot;WifiManagerLeak&quot;) WifiManager wifiManager = (WifiManager) getApplicationContext().getSystemService(Context.WIFI_SERVICE); //判断wifi是否开启 if (!wifiManager.isWifiEnabled()) &#123; wifiManager.setWifiEnabled(true); &#125; WifiInfo wifiInfo = wifiManager.getConnectionInfo(); int ipAddress = wifiInfo.getIpAddress(); String ip = intToIp(ipAddress); //获取ip地址 Toast.makeText(MainActivity.this, ip, Toast.LENGTH_SHORT).show(); startReconnect(); initlistener(); //设置监听 &#125; public static Boolean existsSdcard() &#123; return Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED); &#125; private String intToIp(int i) &#123; // 整型转ip地址 return (i &amp; 0xFF ) + &quot;.&quot; + ((i &gt;&gt; 8 ) &amp; 0xFF) + &quot;.&quot; + ((i &gt;&gt; 16 ) &amp; 0xFF) + &quot;.&quot; + ( i &gt;&gt; 24 &amp; 0xFF) ; &#125; private void initlistener()&#123; //初始化监听 wendu = (TextView) findViewById(R.id.wendu); shidu = (TextView) findViewById(R.id.shidu); t_time = (TextView) findViewById(R.id.t_time); shuixiang = findViewById(R.id.shuixiang); text_nowtime = findViewById(R.id.text_nowtime); send_time = findViewById(R.id.send_time); sw1 = findViewById(R.id.sw1); sw2 = findViewById(R.id.sw2); sw3 = findViewById(R.id.sw3); sw1.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() &#123; @Override public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) &#123; if (isChecked) &#123; publishmessageplus(&quot;A&quot;); &#125; else &#123; publishmessageplus(&quot;B&quot;); &#125; &#125; &#125;); sw2.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() &#123; @Override public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) &#123; if (isChecked) &#123; publishmessageplus(&quot;C&quot;); &#125; else &#123; publishmessageplus(&quot;D&quot;); &#125; &#125; &#125;); sw3.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() &#123; @Override public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) &#123; if (isChecked) &#123; publishmessageplus(&quot;E&quot;); &#125; else &#123; publishmessageplus(&quot;F&quot;); &#125; &#125; &#125;); send_time.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; String send_time_text = t_time.getText().toString(); if (send_time_text.contains(&quot;-&quot;)) &#123; publishMessage(); &#125;else &#123; Toast.makeText(MainActivity.this, &quot;请选择定时时间&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125; &#125;); t_time.setOnClickListener(new View.OnClickListener() &#123; //时间选择器 @Override public void onClick(View v) &#123; Date date = new Date(); SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); String format1 = format.format(date); TimeSelector timeSelector = new TimeSelector(MainActivity.this, new TimeSelector.ResultHandler() &#123; @Override public void handle(String time) &#123; t_time.setText(time); &#125; &#125;, format1, &quot;2050-1-1 24:00:00&quot;); timeSelector.show(); &#125; &#125;); &#125; //新建person表格式 public class Person extends BmobObject &#123; private String name; private String address; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; &#125; private void startReconnect() &#123; scheduler = Executors.newSingleThreadScheduledExecutor(); scheduler.scheduleAtFixedRate(new Runnable() &#123; @Override public void run() &#123; if (!client.isConnected()) &#123; connect(); &#125; &#125; &#125;, 0 * 1000, 10 * 1000, TimeUnit.MILLISECONDS); &#125; private void init() &#123; try &#123; //host为主机名，test为clientid即连接MQTT的客户端ID，一般以客户端唯一标识符表示，MemoryPersistence设置clientid的保存形式，默认为以内存保存 client = new MqttClient(host, &quot;android_studio&quot;, new MemoryPersistence()); //MQTT的连接设置 options = new MqttConnectOptions(); //设置是否清空session,这里如果设置为false表示服务器会保留客户端的连接记录，这里设置为true表示每次连接到服务器都以新的身份连接 options.setCleanSession(true); //设置连接的用户名 options.setUserName(userName); //设置连接的密码 options.setPassword(passWord.toCharArray()); // 设置超时时间 单位为秒 options.setConnectionTimeout(10); // 设置会话心跳时间 单位为秒 服务器会每隔1.5*20秒的时间向客户端发送个消息判断客户端是否在线，但这个方法并没有重连的机制 options.setKeepAliveInterval(20); //设置回调 client.setCallback(new MqttCallback() &#123; @Override public void connectionLost(Throwable cause) &#123; //连接丢失后，一般在这里面进行重连 System.out.println(&quot;connectionLost----------&quot;); &#125; @Override public void deliveryComplete(IMqttDeliveryToken token) &#123; //publish后会执行到这里 System.out.println(&quot;deliveryComplete---------&quot; + token.isComplete()); &#125; @Override public void messageArrived(String topicName, MqttMessage message) throws Exception &#123; //subscribe后得到的消息会执行到这里面 System.out.println(&quot;messageArrived----------&quot;); Message msg = new Message(); msg.what = 1; //收到消息标志位 msg.obj = topicName + &quot;---&quot; + message.toString(); handler.sendMessage(msg); // hander 回传 &#125; &#125;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; private void makeText(String text) &#123; Toast.makeText(MainActivity.this, text, Toast.LENGTH_SHORT).show(); &#125; private void connect() &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; client.connect(options); Message msg = new Message(); msg.what = 2; handler.sendMessage(msg); &#125; catch (Exception e) &#123; e.printStackTrace(); Message msg = new Message(); msg.what = 3; handler.sendMessage(msg); &#125; &#125; &#125;).start(); &#125; private void publishmessageplus(String message2) &#123; if (client == null || !client.isConnected()) &#123; return; &#125; MqttMessage message = new MqttMessage(); message.setPayload(message2.getBytes()); try &#123; client.publish(work_topic,message); &#125; catch (MqttException e) &#123; e.printStackTrace(); &#125; &#125; private void publishMessage() &#123; // 测试发送消息 if (client == null || !client.isConnected()) &#123; return; &#125; MqttMessage message = new MqttMessage(); String time = t_time.getText().toString(); message.setPayload(time.getBytes()); try &#123; client.publish(timeTopic,message); &#125; catch (MqttException e) &#123; e.printStackTrace(); &#125; &#125; @Override public boolean onKeyDown(int keyCode, KeyEvent event) &#123; if (client != null &amp;&amp; keyCode == KeyEvent.KEYCODE_BACK) &#123; try &#123; client.disconnect(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; return super.onKeyDown(keyCode, event); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); try &#123; scheduler.shutdown(); client.disconnect(); &#125; catch (MqttException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void onBackPressed() &#123; DrawerLayout drawer = (DrawerLayout) findViewById(R.id.drawer_layout); if (drawer.isDrawerOpen(GravityCompat.START)) &#123; drawer.closeDrawer(GravityCompat.START); &#125; else &#123; super.onBackPressed(); &#125; &#125; @Override public boolean onCreateOptionsMenu(Menu menu) &#123; // Inflate the menu; this adds items to the action bar if it is present. getMenuInflater().inflate(R.menu.main, menu); return true; &#125; @Override public boolean onOptionsItemSelected(MenuItem item) &#123; int id = item.getItemId(); if (id == R.id.action_settings) &#123; return true; &#125; return super.onOptionsItemSelected(item); &#125;/////////////////////////////////////////////////// @SuppressWarnings(&quot;StatementWithEmptyBody&quot;) @Override public boolean onNavigationItemSelected(MenuItem item) &#123; // Handle navigation view item clicks here. int id = item.getItemId(); if (id == R.id.nav_camera) &#123; Toast.makeText(MainActivity.this, &quot;正在跳转页面&quot;, Toast.LENGTH_SHORT).show(); Intent intent = new Intent(); intent.setClass(MainActivity.this,MqttActivity.class); this.startActivity(intent); &#125; else if (id == R.id.nav_gallery) &#123; Intent intent = new Intent(); intent.setClass(MainActivity.this,baiduActivity.class); this.startActivity(intent); &#125; else if (id == R.id.nav_slideshow) &#123; &#125; else if (id == R.id.nav_manage) &#123; &#125; else if (id == R.id.nav_share) &#123; &#125; else if (id == R.id.nav_send) &#123; &#125; DrawerLayout drawer = (DrawerLayout) findViewById(R.id.drawer_layout); drawer.closeDrawer(GravityCompat.START); return true; &#125;&#125; 硬件代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234#include &lt;ESP8266WiFi.h&gt;#include &lt;ESP8266HTTPClient.h&gt;#include &lt;ArduinoJson.h&gt;#include &quot;SSD1306Wire.h&quot;#include &lt;Wire.h&gt;#include &lt;PubSubClient.h&gt;#include &quot;DHT.h&quot;#define DHTPIN 12 // what digital pin we&apos;re connected to NodeMCU (D6)#define DHTTYPE DHT11SSD1306Wire display(0x3c, D1, D2); // SCL &amp; SDADHT dht(DHTPIN, DHTTYPE);#define wifi_ssid &quot;Android1&quot;#define wifi_password &quot;123456987&quot;#define mqtt_server &quot;60.205.203.64&quot;#define mqtt_user &quot;xianyu&quot;#define mqtt_password &quot;wenzheng&quot;#define humidity_topic &quot;sensor/humidity&quot;#define temperature_celsius_topic &quot;sensor/temperature_celsius&quot;#define water_topic &quot;sensor/water&quot;#define time_topic &quot;sensor/time&quot;#define work_topic &quot;sensor/work&quot;String time_url = &quot;http://quan.suning.com/getSysTime.do&quot;; //时间接口地址WiFiClient espClient;PubSubClient client(espClient);int open_flag = 0;long lastMsg = 0;int value = 0;float h, t, f, w;String msg ;String payload2 = &quot;&quot;; //获取数据储存变量String ding_time, nowtime, nowtime2;char c[] = &quot;&quot;;void setup() &#123; Serial.begin(115200); pinMode(2, OUTPUT); pinMode(0, OUTPUT); pinMode(14, OUTPUT); digitalWrite(2, HIGH); digitalWrite(0, HIGH); digitalWrite(14, HIGH); pinMode(A0, INPUT); display.init(); display.flipScreenVertically(); drawFontFaceDemo(); //开机画面 dht.begin(); display.clear(); //清屏 setup_wifi(); client.setServer(mqtt_server, 1883); //链接MQTT服务器 client.setCallback(callback);//数据回调&#125;void drawFontFaceDemo() &#123; display.setTextAlignment(TEXT_ALIGN_LEFT); display.setFont(ArialMT_Plain_10); display.drawString(0, 0, &quot;Hello MQTT&quot;); display.setFont(ArialMT_Plain_16); display.drawString(0, 10, &quot;Hello MQTT&quot;); display.setFont(ArialMT_Plain_24); display.drawString(0, 26, &quot;Hello MQTT&quot;); display.display(); delay(1000); display.clear();&#125;void callback(char* topic, byte* payload, unsigned int length) //接收消息&#123; Serial.print(&quot;Message arrived [&quot;); Serial.print(topic); Serial.print(&quot;] &quot;); for (int i = 0; i &lt; length; i++) &#123; Serial.print((char)payload[i]); msg = msg + (char)payload[i]; &#125; Serial.println(topic); Serial.println(msg); //消息处理 收到的数据格式为：2018-12-23 12:00 if (String(topic) == &quot;sensor/time&quot;) &#123; ding_time = msg; open_flag = 1; // 触发指令标志位 = 1 防止多次触发。 &#125; if (String(topic) == &quot;sensor/work&quot; ) &#123; if (msg == &quot;A&quot;) &#123; digitalWrite(2, LOW); &#125; else if (msg == &quot;B&quot;) &#123; digitalWrite(2, HIGH); &#125; else if (msg == &quot;C&quot;) &#123; digitalWrite(0, LOW); &#125; else if (msg == &quot;D&quot;) &#123; digitalWrite(0, HIGH); &#125;else if (msg == &quot;E&quot;) &#123; digitalWrite(14, LOW); &#125;else if (msg == &quot;F&quot;) &#123; digitalWrite(14, HIGH); &#125; &#125; msg = &quot;&quot;;&#125;String macToStr(const uint8_t* mac)&#123; String result; for (int i = 0; i &lt; 6; ++i) &#123; result += String(mac[i], 16); if (i &lt; 5) result += &apos;:&apos;; &#125; return result;&#125;void setup_wifi() &#123; delay(10); // We start by connecting to a WiFi network Serial.println(); Serial.print(&quot;Connecting to &quot;); display.setFont(ArialMT_Plain_10); display.drawString(0, 0, wifi_ssid); display.display(); Serial.println(wifi_ssid); WiFi.begin(wifi_ssid, wifi_password); while (WiFi.status() != WL_CONNECTED) &#123; delay(500); Serial.print(&quot;.&quot;); display.drawString(0, 10, &quot;Wait wifi connected&quot;); display.display(); &#125; Serial.println(&quot;&quot;); Serial.println(&quot;WiFi connected&quot;); Serial.println(&quot;IP address: &quot;); Serial.println(WiFi.localIP());&#125;void reconnect() &#123; // Loop until we&apos;re reconnected while (!client.connected()) &#123; Serial.print(&quot;Attempting MQTT connection...&quot;); String clientName; clientName += &quot;esp8266-&quot;; uint8_t mac[6]; WiFi.macAddress(mac); clientName += macToStr(mac); clientName += &quot;-&quot;; clientName += String(micros() &amp; 0xff, 16); Serial.print(&quot;Connecting to &quot;); Serial.print(mqtt_server); Serial.print(&quot; as &quot;); Serial.println(clientName); if (client.connect((char*) clientName.c_str())) &#123; //if (client.connect((char*) clientName.c_str()), mqtt_user, mqtt_password)) &#123; Serial.println(&quot;connected&quot;); client.subscribe(time_topic);//订阅定时主题用来接收定时信息 client.subscribe(work_topic);//订阅工作主题来接收指令 &#125; else &#123; Serial.print(&quot;failed, rc=&quot;); Serial.print(client.state()); Serial.println(&quot; try again in 5 seconds&quot;); // Wait 5 seconds before retrying delay(5000); &#125; &#125;&#125;/*********************************获取时间**************************************/void get_time()&#123; HTTPClient http; http.begin(time_url); int httpCode = http.GET(); if (httpCode &gt; 0) &#123; payload2 = http.getString(); Serial.println(payload2); /************************************json 数据处理********************************************/ DynamicJsonBuffer jsonBuffer; String input = payload2; JsonObject&amp; root = jsonBuffer.parseObject(input); String now_time = root[String(&quot;sysTime2&quot;)]; String now_time2 = root[String(&quot;sysTime1&quot;)]; //这是清除格式的时间 方便比较 nowtime = now_time; // 20181225193600 nowtime2 = now_time2.substring(0, 12); //清除秒位 方便比较 &#125; http.end();&#125;void bijiao(String a, String b)&#123; String t_val = a.substring(4, 12); //清除年 方便比较 int N_T = t_val.toInt(); //Serial.println(N_T); b.replace(&quot;-&quot;, &quot;&quot;); b.replace(&quot;:&quot;, &quot;&quot;); b.replace(&quot; &quot;, &quot;&quot;); Serial.println(b); String d_val = b.substring(4, 12); //清除年 方便比较 int D_T = d_val.toInt(); // Serial.println(D_T); if ((N_T &gt;= D_T) &amp;&amp; (D_T != 0)) &#123; if (open_flag) &#123; Serial.println (&quot;6666666666666&quot;); digitalWrite(2, LOW); open_flag = 0; // 触发指令标志位 = 0 防止多次触发。 &#125; &#125;&#125;void loop() &#123; float h = dht.readHumidity(); float t = dht.readTemperature(); float w = analogRead(A0); // Serial.println(w); if (w &lt; 500) w = 500; w = map(w, 500, 1024, 100 , 0); //映射模拟量数值为0-100% display.setFont(ArialMT_Plain_16); display.drawString(0, 0, &quot;T:&quot;); display.drawString(20, 0, String(t).c_str()); display.drawString(100, 0, &quot;C&quot;); display.drawString(0, 15, &quot;H:&quot;); display.drawString(20, 15, String(h).c_str()); display.drawString(100, 15, &quot;%&quot;); display.setFont(ArialMT_Plain_10); display.drawString(0, 30, &quot;W:&quot;); display.drawString(20, 30, String(w).c_str()); display.drawString(100, 30, &quot;%&quot;); display.drawString(0, 40, &quot;M:&quot;); display.drawString(20, 40, ding_time); display.drawString(0, 50, &quot;N:&quot;); display.drawString(20, 50, nowtime); display.display(); if (!client.connected()) &#123; reconnect(); &#125; client.loop(); long now = millis(); if (now - lastMsg &gt; 2000) &#123; lastMsg = now; ++value; get_time(); client.publish(temperature_celsius_topic, String(t).c_str(), true); //上传温度数据 delay(100); client.publish(humidity_topic, String(h).c_str(), true); //上传湿度数据 delay(100); client.publish(water_topic, String(w).c_str(), true); //上传水位数据 bijiao(nowtime2, ding_time); &#125; display.clear(); //显示屏清屏&#125;","categories":[],"tags":[{"name":"MQTT","slug":"MQTT","permalink":"http://yoursite.com/tags/MQTT/"}]},{"title":"我的2018","slug":"我的2018","date":"2019-01-01T02:53:00.000Z","updated":"2019-01-01T12:00:27.419Z","comments":true,"path":"2019/01/01/我的2018/","link":"","permalink":"http://yoursite.com/2019/01/01/我的2018/","excerpt":"","text":"今天是元旦，嗯嗯写了一天的代码。昨天晚上发了一个说说，总结我的2018 2018 收获颇丰。2019努力前行！2018回顾参加了小比赛，获得10000创业基金（虽然学校还欠着我）。法人独资创立业森信息技术有限公司，目前已完成所有手续。自学安卓编程，累计制作安卓项目5款，《校网助手》已停更，且在校园中运行，出售三款软件及源码（物联网相关），累计1700元。课余接项目制作，咸鱼累计出售9100元。（不要问我钱去哪了，我也不知道。）自己用代码挣的钱买了苹果手机，买了衣服，在校期间，边上学，边实习上班，工资给家里买了液晶电视，由于其他原因无奈给家里买空调的计划只能往后拖一些/可爱\u0003。最幸福的是六年的爱情依旧很美好。2019愿望中耳炎，已经快一年了，该好了吧。在郑州和女朋友一起租房子上班，前半年把大学四年学费贷款还了。和公司里同事多学习编程和前端，好好学习，天天向上。努力学习编程，利用上班之余，成立小工作室接项目补贴房租。挣更多钱，买单反相机，带女朋友旅行，给女朋友买衣服，买化妆品，买首饰，买好吃的……抽空继续学习吉他，琴弦不能锈了。多陪陪女朋友。多陪陪女朋友。多陪陪女朋友 2018学习 2018工作 2018收获 愿2019自己更加努力。收获更多。","categories":[],"tags":[{"name":"年终总结","slug":"年终总结","permalink":"http://yoursite.com/tags/年终总结/"}]},{"title":"拖更《工作回顾》","slug":"拖更《工作回顾》","date":"2018-12-26T02:53:00.000Z","updated":"2018-12-31T05:13:24.000Z","comments":true,"path":"2018/12/26/拖更《工作回顾》/","link":"","permalink":"http://yoursite.com/2018/12/26/拖更《工作回顾》/","excerpt":"","text":"1今天是2018年11月30日 好久没有更新博客了，内心其实一直想着，，无奈最近工作太忙，再加上我发布博客还是相当的难的，首先我电脑有问题，用不了GIT工具，（装的烂系统） 首先我要用csdn来编写MD文档（正好也可以存在csdn上） 然后我要下载下来 在用优盘拷贝下来，然后用别人的电脑发布到我github博客上。 最后。。。我很懒 总结一下最近的成果吧 siri 3.0 的完整版本开发 咸鱼订单安卓软件项目的开发（独立完成） 咸鱼订单毕业设计的制作和安卓的开发 公司最近的项目《基于NB-iot的工业数据采集》 安卓项目的蓝牙调试成功 下面是图集","categories":[],"tags":[{"name":"托更","slug":"托更","permalink":"http://yoursite.com/tags/托更/"}]},{"title":"小白的物联网全栈开发之路","slug":"小白的物联网全栈开发之路","date":"2018-10-30T02:53:00.000Z","updated":"2018-10-31T09:24:46.000Z","comments":true,"path":"2018/10/30/小白的物联网全栈开发之路/","link":"","permalink":"http://yoursite.com/2018/10/30/小白的物联网全栈开发之路/","excerpt":"","text":"小白的物联网全栈开发之路 前两天自己成功完成了物联网的相对全栈开发，包括服务器，包括单片机，包括安卓软件，一气呵成，特作文记之。最近组建了一个小群，感兴趣的可以加入一起玩：476840321 单片机也是很简单的，用的esp8266最小系统。和oled 以及温湿度上报。 阿里云远程服务器也是很稳定的，经过我的测试还是非常舒服的。速度也非常快。安卓软件采用易安卓开发，界面很简单，但是效果非常好，开机自动登录服务器，自动订阅消息，温度上报也正常，美滋滋。单片机的代码采用arduino编写esp8266固件，莫名的很快，果然还是单片机玩着顺手，比嵌入式简单的多呀。 接下来我又开发了Siri控制esp8266的1.0 2.0 以及稳定完善版本的3.0系统，比较懒，也很忙，没空记录呀。","categories":[],"tags":[{"name":"mqtt","slug":"mqtt","permalink":"http://yoursite.com/tags/mqtt/"}]},{"title":"ESP8266学习资料","slug":"ESP8266嵌入式开发资料汇总","date":"2018-10-17T02:53:00.000Z","updated":"2018-10-27T08:10:22.000Z","comments":true,"path":"2018/10/17/ESP8266嵌入式开发资料汇总/","link":"","permalink":"http://yoursite.com/2018/10/17/ESP8266嵌入式开发资料汇总/","excerpt":"","text":"ESP8266学习资料 99元物联网全栈开发视频教程链接：https://pan.baidu.com/s/1lG8FJhQLW98PRJ9YUmqSEQ 提取码：fk9q 建议去技新网购买收费教程，请不要盗卖。加群获得更多资料教程：476840321","categories":[],"tags":[{"name":"ESP8266","slug":"ESP8266","permalink":"http://yoursite.com/tags/ESP8266/"}]},{"title":"阿里云自建服务器esp8266和mqtt客户端成功对接","slug":"参考大神教程完成阿里云自建服务器esp8266和mqtt客户端成功对接","date":"2018-10-16T02:53:00.000Z","updated":"2018-10-16T06:38:14.000Z","comments":true,"path":"2018/10/16/参考大神教程完成阿里云自建服务器esp8266和mqtt客户端成功对接/","link":"","permalink":"http://yoursite.com/2018/10/16/参考大神教程完成阿里云自建服务器esp8266和mqtt客户端成功对接/","excerpt":"","text":"阿里云自建服务器esp8266和mqtt客户端成功对接 阿里云服务器部分参考esp8266嵌入式大神资料：大神博客最近组建了一个小群，感兴趣的可以加入一起玩：476840321 单片机也是很简单的，用的esp8266最小系统。 过程中间遇到了很多问题，还好都一步步解决了，首先是linux的一些常用命令，因为服务器买的是阿里云的空间，跑的是linux的系统，按照网上的资料和教程，总算搞定了。linux常用命令集：https://www.cnblogs.com/pengwenzheng/p/9795909.html其次是硬件端的编程，esp8266的固件的编写。以及mqtt通讯SDK的修改（参考安信可和技新的资料） 代码备份如下：mqtt_config.h 1234567891011121314151617181920212223242526272829303132333435363738/*IMPORTANT: the following configuration maybe need modified*//***********************************************************************************************************************************************************************************************************************************************************/#define CFG_HOLDER 0x66666670 // 持有人标识(只有更新此数值，系统参数才会更新) /* Change this value to load default configurations *//*DEFAULT CONFIGURATIONS*/// 注：【MQTT协议规定：连接服务端的每个客户端都必须有唯一的客户端标识符（ClientId）】。如果两相同ID的客户端不断重连，就会进入互踢死循环//--------------------------------------------------------------------------------------------------------------------------------------#define MQTT_HOST &quot;购买的ip&quot; // MQTT服务端域名/IP地址 // the IP address or domain name of your MQTT server or MQTT broker ,such as &quot;mqtt.yourdomain.com&quot;#define MQTT_PORT 1883 // 网络连接端口号 // the listening port of your MQTT server or MQTT broker#define MQTT_CLIENT_ID &quot;pengwenzheng&quot; // 官方例程中是&quot;Device_ID&quot; // 客户端标识符 // the ID of yourself, any string is OK,client would use this ID register itself to MQTT server#define MQTT_USER &quot;admin&quot; // MQTT用户名 // your MQTT login name, if MQTT server allow anonymous login,any string is OK, otherwise, please input valid login name which you had registered#define MQTT_PASS &quot;public&quot; // MQTT密码 // you MQTT login password, same as above#define STA_SSID &quot;maker_space&quot; // WIFI名称 // your AP/router SSID to config your device networking#define STA_PASS &quot;chuangke666&quot; // WIFI密码 // your AP/router password#define STA_TYPE AUTH_WPA2_PSK#define DEFAULT_SECURITY NO_TLS // 加密传输类型【默认不加密】 // very important: you must config DEFAULT_SECURITY for SSL/TLS#define CA_CERT_FLASH_ADDRESS 0x77 // 【CA证书】烧录地址 // CA certificate address in flash to read, 0x77 means address 0x77000#define CLIENT_CERT_FLASH_ADDRESS 0x78 // 【设备证书】烧录地址 // client certificate and private key address in flash to read, 0x78 means address 0x78000/*********************************************************************************************************************************************************************************************************************************************************************************//*Please Keep the following configuration if you have no very deep understanding of ESP SSL/TLS*/#define CFG_LOCATION 0x79 // 系统参数的起始扇区 /* Please don&apos;t change or if you know what you doing */#define MQTT_BUF_SIZE 1024 // MQTT缓存大小#define MQTT_KEEPALIVE 120 // 保持连接时长 /*second*/#define MQTT_RECONNECT_TIMEOUT 5 // 重连超时时长 /*second*/#define MQTT_SSL_ENABLE // SSL使能 //* Please don&apos;t change or if you know what you doing */#define QUEUE_BUFFER_SIZE 2048 // 消息队列的缓存大小//#define PROTOCOL_NAMEv31 // 使用MQTT协议【v31】版本 /*MQTT version 3.1 compatible with Mosquitto v0.15*/#define PROTOCOL_NAMEv311 // 使用MQTT协议【v311】版本 /*MQTT version 3.11 compatible with https://eclipse.org/paho/clients/testing/*/#endif // __MQTT_CONFIG_H__ 接下来的思路：准备写安卓端的控制程序，和硬件和网络进行对接，方案1： 利用java编写（这个还是比较难的）方案2： 利用apicloud编写，JavaScript编写（需要购买资料）发工资了再买。方案3： 利用E4A易安卓进行编写，这个应该很简单，准备试一下。","categories":[],"tags":[{"name":"mqtt","slug":"mqtt","permalink":"http://yoursite.com/tags/mqtt/"}]},{"title":"Siri对接esp8266语音控制自制智能家居","slug":"Siri 捷径邂逅esp8266实现的智能家居控制","date":"2018-10-11T02:53:00.000Z","updated":"2018-10-14T08:40:28.000Z","comments":true,"path":"2018/10/11/Siri 捷径邂逅esp8266实现的智能家居控制/","link":"","permalink":"http://yoursite.com/2018/10/11/Siri 捷径邂逅esp8266实现的智能家居控制/","excerpt":"","text":"##Siri对接esp8266语音控制自制智能家居##首先上视频，看下效果： 实际安装效果 其次是esp8266代码在本人github里，转载请注明出处。https://github.com/az666/Siri-and-esp8266 下面是ios捷径的配置（请用苹果内置浏览器打开）： https://www.icloud.com/shortcuts/cc23835ce624430f83e5628b88bce13e 工作原理：esp8266建立小型局域网服务器，siri通过捷径访问ip esp8266检测到指定ip执行相应动作。","categories":[],"tags":[{"name":"Siri","slug":"Siri","permalink":"http://yoursite.com/tags/Siri/"}]},{"title":"九月工作阶段总结","slug":"九月阶段总结","date":"2018-09-30T02:53:00.000Z","updated":"2018-09-30T01:40:38.000Z","comments":true,"path":"2018/09/30/九月阶段总结/","link":"","permalink":"http://yoursite.com/2018/09/30/九月阶段总结/","excerpt":"九月阶段总结 今天是九月的最后一天，终于有时间总结一下最近的学习和工作记录下最近的大事件，首先自己进入了一家公司开始了自己的工作，工作很舒服，很庆幸做的也是自己喜欢的工作，我在部门负责硬件开发，其实也谈不上开发，毕竟自己学的东西比较少，也是由部门同事带着我学习和研究，同事对我都很好，这是最舒服的一点。其次就是自己的公司终于建的差不多了，准备毕业之后公司工作同步发展，开始自己的工作、创业混合前进策略。。。 具体的工作成果 还是先说工作，最近公司的第一个项目就是做工业仪器仪表的数据采集，我们团队进行元件选型到硬件对接，到程序编写，也是费了九牛二虎之力，最终效果还是很明显的，还是很成功的。尤其是代码部分，我也是研究了好几天才完成了单片机与RS485的通讯，成功读取仪表寄存器数据并对接机智云实现了数据的远程传输。","text":"九月阶段总结 今天是九月的最后一天，终于有时间总结一下最近的学习和工作记录下最近的大事件，首先自己进入了一家公司开始了自己的工作，工作很舒服，很庆幸做的也是自己喜欢的工作，我在部门负责硬件开发，其实也谈不上开发，毕竟自己学的东西比较少，也是由部门同事带着我学习和研究，同事对我都很好，这是最舒服的一点。其次就是自己的公司终于建的差不多了，准备毕业之后公司工作同步发展，开始自己的工作、创业混合前进策略。。。 具体的工作成果 还是先说工作，最近公司的第一个项目就是做工业仪器仪表的数据采集，我们团队进行元件选型到硬件对接，到程序编写，也是费了九牛二虎之力，最终效果还是很明显的，还是很成功的。尤其是代码部分，我也是研究了好几天才完成了单片机与RS485的通讯，成功读取仪表寄存器数据并对接机智云实现了数据的远程传输。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 float getrs485()//读取rs485,波特率：9600； 校验位：无； 停止位：1 位； 数据位：8；数据包长度为7字节&#123; int x, cnt,pmval,readcmd[7]; unsigned char gdata,eFlag,rbytes=0; float A; cnt=0; eFlag =0; while(mySerial.available()&gt;0) &#123; gdata = mySerial.read();//保存接收字符 // Serial.print(gdata,HEX); if(gdata==254&amp;&amp;eFlag==0) &#123; eFlag=1; &#125; if(eFlag==1) &#123; readcmd[rbytes++]=gdata; &#125; delay(2); cnt++; if(cnt&gt;100) return 0; if(rbytes==7)//完整帧 &#123; break; &#125; &#125; if(rbytes==0) return 0;/*Serial.println(&quot;&quot;);Serial.println(readcmd[0]);Serial.println(readcmd[1],HEX);Serial.println(readcmd[2],HEX);Serial.println(readcmd[3],HEX);Serial.println(readcmd[4],HEX);Serial.println(readcmd[5],HEX);Serial.println(readcmd[6],HEX);*/x= x+readcmd[3];x&lt;&lt;=8; //左移8位x+= readcmd[4]; //相加A = x;if (A==0) A=4000; //排除未校测时的误差，默认为零//A=A*1.2375/1000-4.75; //单片机内部计算，有待调试x=0;return A;&#125; 学习上的话，最近学校要搞学科竞赛，班里同学大多不会做，或者没时间做，最终这个艰巨的任务就交给了我，没曾想，班里同学，学院学弟，瞬间来了20几个人让我来做作品，真的也是相当无奈。没办法，昨天刚采购了物品，国庆七天假期准备加加班，再搞一波。 而且令我高兴地另一件事就是，我之前把我在互联网＋参赛的作品卖给了一个大学生，他也靠着这个作品在北大获得了“国际创新创业大赛”的二等奖。很开心。","categories":[],"tags":[{"name":"工作","slug":"工作","permalink":"http://yoursite.com/tags/工作/"}]},{"title":"MQTT本地服务器搭建","slug":"本地MQTT服务器的搭建","date":"2018-09-18T02:53:00.000Z","updated":"2018-09-18T02:53:02.000Z","comments":true,"path":"2018/09/18/本地MQTT服务器的搭建/","link":"","permalink":"http://yoursite.com/2018/09/18/本地MQTT服务器的搭建/","excerpt":"","text":"参考教程：嵌入式大神链接 下一步将参考其教程制作嵌入式MQTT局域网通讯，暂时做设备上报吧。","categories":[],"tags":[{"name":"物联网","slug":"物联网","permalink":"http://yoursite.com/tags/物联网/"}]},{"title":"维控PLC学习笔记","slug":"维控PLC学习笔记","date":"2018-08-15T13:45:00.000Z","updated":"2018-08-15T10:30:16.000Z","comments":true,"path":"2018/08/15/维控PLC学习笔记/","link":"","permalink":"http://yoursite.com/2018/08/15/维控PLC学习笔记/","excerpt":"","text":"维控PLC学习笔记 12345目录：1. 主要编程思想2. 梯形图3. 视频教程 4. 网站和论坛 依旧采用我多年的凌乱记忆法： 感觉PLC就像一个处理函数的集成电路设备，我用的是老师给的维控PLC官网介绍说它很牛逼，可以兼容三菱FX系列而且比三菱快，价格也比三菱便宜。（这波抄袭很稳）， 因为我老师有一个公司是做工业包装机的，所以我这里有很多传感器可以使用。最近研究了称重传感器和触摸屏还有步进电机，其实这几样已经可以做一个工业的称重包装机了。 模块通讯重要的指令","categories":[],"tags":[{"name":"PLC","slug":"PLC","permalink":"http://yoursite.com/tags/PLC/"}]},{"title":"阶段总结","slug":"2018年7月阶段总结（安卓开发）（远程控制）（语音控制）","date":"2018-08-03T13:45:00.000Z","updated":"2018-08-22T13:39:54.000Z","comments":true,"path":"2018/08/03/2018年7月阶段总结（安卓开发）（远程控制）（语音控制）/","link":"","permalink":"http://yoursite.com/2018/08/03/2018年7月阶段总结（安卓开发）（远程控制）（语音控制）/","excerpt":"","text":"阶段总结 总结一下最近半个月的成果： 首先是做出了嵌入式的延时智能开关 其次焊接了智能开关3D镂空电路 然后最近学了APIcloud进行了我的另一款APP的开发。正好对接了上面的3D电路板实现了语音远程控制，再加入我的算法，实现了语音识别的精确判断。并且对接的讯飞语音平台，所以，方言识别也不在话下。 嵌入式的延时智能开关 智能开关3D镂空电路 APIcloud开发安卓应用 最近的收获还是很多的，从学一个新东西到最后做出来，经历了很多，但也学会了很多，很开心。","categories":[],"tags":[{"name":"总结","slug":"总结","permalink":"http://yoursite.com/tags/总结/"}]},{"title":"3D镂空智能插座mini透明探索版","slug":"3D镂空智能插座mini透明探索版","date":"2018-07-27T14:53:00.000Z","updated":"2018-08-22T13:54:36.000Z","comments":true,"path":"2018/07/27/3D镂空智能插座mini透明探索版/","link":"","permalink":"http://yoursite.com/2018/07/27/3D镂空智能插座mini透明探索版/","excerpt":"","text":"3D镂空智能插座mini透明探索版 纯手工打造，3D镂空电路，以前在某论坛见过，这次花了几个小时时间制作了这一个镂空电路，效果很好，非常棒，运行正常，同时也学会了稳压电路和最小系统的搭建，以及esp12F烧写固件的偶然性，即QIO与DIO的刷机方式的变动。","categories":[],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"http://yoursite.com/tags/嵌入式/"}]},{"title":"智能门禁系统2.0开发","slug":"智能门禁系统2.0开发","date":"2018-07-27T14:53:00.000Z","updated":"2018-09-18T02:51:38.000Z","comments":true,"path":"2018/07/27/智能门禁系统2.0开发/","link":"","permalink":"http://yoursite.com/2018/07/27/智能门禁系统2.0开发/","excerpt":"继工作室装修以后，门禁系统1.0再度开发为2.0，这次与上次采用了不同的编程方案，虽然用的依然是机智云，但是采用的方案不同，1、上次采用mcu方案，就是用的esp8266＋arduino开发的，而这次我用的仅仅一块儿esp8266（nodemcu）搞定，2、驱动电机的方式也有所改变，上次采用的继电器进行的电机转向，这次采用的l298N驱动，效果更好。3、 同时也有很多细节发生了改变。 视频地址 编写代码 装机调试 代码部分","text":"继工作室装修以后，门禁系统1.0再度开发为2.0，这次与上次采用了不同的编程方案，虽然用的依然是机智云，但是采用的方案不同，1、上次采用mcu方案，就是用的esp8266＋arduino开发的，而这次我用的仅仅一块儿esp8266（nodemcu）搞定，2、驱动电机的方式也有所改变，上次采用的继电器进行的电机转向，这次采用的l298N驱动，效果更好。3、 同时也有很多细节发生了改变。 视频地址 编写代码 装机调试 代码部分 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186/*************************************************************** @file user_main.c* @brief The program entry file* @author Gizwits* @date 2017-07-19* @version V03030000* @copyright Gizwits** @note 鏈烘櫤浜�.鍙负鏅鸿兘纭欢鑰岀敓* Gizwits Smart Cloud for Smart Products* 閾炬帴|澧炲�贾祙寮�鏀緗涓珛|瀹夊叏|鑷湁|鑷敱|鐢熸��* www.gizwits.com************************************************************/#include &quot;ets_sys.h&quot;#include &quot;osapi.h&quot;#include &quot;user_interface.h&quot;#include &quot;gagent_soc.h&quot;#include &quot;user_devicefind.h&quot;#include &quot;user_webserver.h&quot;#include &quot;gizwits_product.h&quot;#include &quot;driver/hal_key.h&quot;#if ESP_PLATFORM#include &quot;user_esp_platform.h&quot;#endif#ifdef SERVER_SSL_ENABLE#include &quot;ssl/cert.h&quot;#include &quot;ssl/private_key.h&quot;#else#ifdef CLIENT_SSL_ENABLEunsigned char *default_certificate;unsigned int default_certificate_len = 0;unsigned char *default_private_key;unsigned int default_private_key_len = 0;#endif#endif/**@&#125; */ /**@name Key related definitions * @&#123;*/#define GPIO_KEY_NUM 2 ///&lt; Defines the total number of key members#define KEY_0_IO_MUX PERIPHS_IO_MUX_GPIO0_U ///&lt; ESP8266 GPIO function#define KEY_0_IO_NUM 0 ///&lt; ESP8266 GPIO number#define KEY_0_IO_FUNC FUNC_GPIO0 ///&lt; ESP8266 GPIO name#define KEY_1_IO_MUX PERIPHS_IO_MUX_MTMS_U ///&lt; ESP8266 GPIO function#define KEY_1_IO_NUM 14 ///&lt; ESP8266 GPIO number#define KEY_1_IO_FUNC FUNC_GPIO14 ///&lt; ESP8266 GPIO nameLOCAL key_typedef_t * singleKey[GPIO_KEY_NUM]; ///&lt; Defines a single key member array pointerLOCAL keys_typedef_t keys; ///&lt; Defines the overall key module structure pointer /**@&#125; */bool input_result;/*** Key1 key short press processing* @param none* @return none*/LOCAL void ICACHE_FLASH_ATTR key1ShortPress(void)&#123; GIZWITS_LOG(&quot;#### KEY1 short press ,Production Mode\\n&quot;); gizwitsSetMode(WIFI_PRODUCTION_TEST);&#125;/*** Key1 key presses a long press* @param none* @return none*/LOCAL void ICACHE_FLASH_ATTR key1LongPress(void)&#123; GIZWITS_LOG(&quot;#### key1 long press, default setup\\n&quot;); gizwitsSetMode(WIFI_RESET_MODE);&#125;/*** Key2 key to short press processing* @param none* @return none*/LOCAL void ICACHE_FLASH_ATTR key2ShortPress(void)&#123; GIZWITS_LOG(&quot;#### key2 short press, soft ap mode \\n&quot;); gizwitsSetMode(WIFI_SOFTAP_MODE);&#125;/*** Key2 button long press* @param none* @return none*/LOCAL void ICACHE_FLASH_ATTR key2LongPress(void)&#123; GIZWITS_LOG(&quot;#### key2 long press, airlink mode\\n&quot;); gizwitsSetMode(WIFI_AIRLINK_MODE);&#125;/*** Key to initialize* @param none* @return none*/LOCAL void ICACHE_FLASH_ATTR keyInit(void)&#123; singleKey[0] = keyInitOne(KEY_0_IO_NUM, KEY_0_IO_MUX, KEY_0_IO_FUNC, key1LongPress, key1ShortPress); singleKey[1] = keyInitOne(KEY_1_IO_NUM, KEY_1_IO_MUX, KEY_1_IO_FUNC, key2LongPress, key2ShortPress); keys.singleKey = singleKey; keyParaInit(&amp;keys); PIN_FUNC_SELECT(PERIPHS_IO_MUX_MTDI_U, FUNC_GPIO12); //GPIO12初始化 GPIO_OUTPUT_SET(GPIO_ID_PIN(12), 1);//GPIO12 低电平输出 PIN_FUNC_SELECT(PERIPHS_IO_MUX_MTCK_U, FUNC_GPIO13); GPIO_OUTPUT_SET(GPIO_ID_PIN(13), 0); PIN_FUNC_SELECT(PERIPHS_IO_MUX_U0RXD_U, FUNC_GPIO3); GPIO_OUTPUT_SET(GPIO_ID_PIN(3), 0); PIN_FUNC_SELECT(PERIPHS_IO_MUX_GPIO4_U, FUNC_GPIO4); GPIO_DIS_OUTPUT(FUNC_GPIO4);&#125;/*** @brief user_rf_cal_sector_set* Use the 636 sector (2544k ~ 2548k) in flash to store the RF_CAL parameter* @param none* @return none*/uint32_t ICACHE_FLASH_ATTR user_rf_cal_sector_set()&#123; return 636;&#125;////////////////////////*** @brief program entry function* In the function to complete the user-related initialization* @param none* @return none*/void ICACHE_FLASH_ATTR user_init(void)&#123; uint32_t system_free_size = 0; wifi_station_set_auto_connect(1); wifi_set_sleep_type(NONE_SLEEP_T);//set none sleep mode espconn_tcp_set_max_con(10); uart_init_3(9600,115200); UART_SetPrintPort(1); GIZWITS_LOG( &quot;---------------SDK version:%s--------------\\n&quot;, system_get_sdk_version()); GIZWITS_LOG( &quot;system_get_free_heap_size=%d\\n&quot;,system_get_free_heap_size()); struct rst_info *rtc_info = system_get_rst_info(); GIZWITS_LOG( &quot;reset reason: %x\\n&quot;, rtc_info-&gt;reason); if (rtc_info-&gt;reason == REASON_WDT_RST || rtc_info-&gt;reason == REASON_EXCEPTION_RST || rtc_info-&gt;reason == REASON_SOFT_WDT_RST) &#123; if (rtc_info-&gt;reason == REASON_EXCEPTION_RST) &#123; GIZWITS_LOG(&quot;Fatal exception (%d):\\n&quot;, rtc_info-&gt;exccause); &#125; GIZWITS_LOG( &quot;epc1=0x%08x, epc2=0x%08x, epc3=0x%08x, excvaddr=0x%08x, depc=0x%08x\\n&quot;, rtc_info-&gt;epc1, rtc_info-&gt;epc2, rtc_info-&gt;epc3, rtc_info-&gt;excvaddr, rtc_info-&gt;depc); &#125; if (system_upgrade_userbin_check() == UPGRADE_FW_BIN1) &#123; GIZWITS_LOG( &quot;---UPGRADE_FW_BIN1---\\n&quot;); &#125; else if (system_upgrade_userbin_check() == UPGRADE_FW_BIN2) &#123; GIZWITS_LOG( &quot;---UPGRADE_FW_BIN2---\\n&quot;); &#125; keyInit(); gizwitsInit(); dh11Init(); GIZWITS_LOG(&quot;--- system_free_size = %d ---\\n&quot;, system_get_free_heap_size());&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244/*************************************************************** @file gizwits_product.c* @brief Control protocol processing, and platform-related hardware initialization* @author Gizwits* @date 2017-07-19* @version V03030000* @copyright Gizwits** @note 鏈烘櫤浜�.鍙负鏅鸿兘纭欢鑰岀敓* Gizwits Smart Cloud for Smart Products* 閾炬帴|澧炲�贾祙寮�鏀緗涓珛|瀹夊叏|鑷湁|鑷敱|鐢熸��* www.gizwits.com************************************************************/#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &quot;gizwits_product.h&quot;#include &quot;driver/hal_key.h&quot;#include &quot;driver/hal_temp_hum.h&quot;/** User area The current device state structure */dataPoint_t currentDataPoint;bool isTimer;long timer_timers;long time_mills;//定义总秒数static os_timer_t os_timer;static os_timer_t delay_timer;void stop(void)&#123; GPIO_OUTPUT_SET(GPIO_ID_PIN(13), 0); GPIO_OUTPUT_SET(GPIO_ID_PIN(3), 0); GPIO_OUTPUT_SET(GPIO_ID_PIN(12), 1);&#125;void open()&#123; GPIO_OUTPUT_SET(GPIO_ID_PIN(13), 0); GPIO_OUTPUT_SET(GPIO_ID_PIN(3), 1);&#125;void Led_Task_Run(void)&#123; //开门 open(); //开灯 GPIO_OUTPUT_SET(GPIO_ID_PIN(12), 0); //根据继电器的种类和要定时的任务而定。这是低电平触发继电器的定时开机功能。 isTimer=false; //执行完毕，我们要把定时时间设置0 ,定时使能状态为false timer_timers= 0;&#125;void Led_Task_Off(void)&#123;//开灯 GPIO_OUTPUT_SET(GPIO_ID_PIN(12), 1); //根据继电器的种类和要定时的任务而定。这是低电平触发继电器的定时关机功能。 isTimer=false; //执行完毕，我们要把定时时间设置0 ,定时使能状态为false timer_timers= 0;&#125;int8_t ICACHE_FLASH_ATTR gizwitsEventProcess(eventInfo_t *info, uint8_t *data, uint32_t len)&#123; uint8_t i = 0; dataPoint_t * dataPointPtr = (dataPoint_t *)data; moduleStatusInfo_t * wifiData = (moduleStatusInfo_t *)data; if((NULL == info) || (NULL == data)) &#123; GIZWITS_LOG(&quot;!!! gizwitsEventProcess Error \\n&quot;); return -1; &#125; for(i = 0; i &lt; info-&gt;num; i++) &#123; switch(info-&gt;event[i]) &#123; case EVENT_on_off : currentDataPoint.valueon_off = dataPointPtr-&gt;valueon_off; GIZWITS_LOG(&quot;Evt: EVENT_on_off %d \\n&quot;, currentDataPoint.valueon_off); if(0x01 == currentDataPoint.valueon_off) &#123; GPIO_OUTPUT_SET(GPIO_ID_PIN(12), 0); open(); &#125; else &#123; GPIO_OUTPUT_SET(GPIO_ID_PIN(12), 1); &#125; break; case EVENT_T_on_off : currentDataPoint.valueT_on_off = dataPointPtr-&gt;valueT_on_off; GIZWITS_LOG(&quot;Evt: EVENT_T_on_off %d \\n&quot;, currentDataPoint.valueT_on_off); if(0x01 == currentDataPoint.valueT_on_off) &#123; isTimer=true;//开启定时器 &#125; else &#123; /** 关闭该定时器 */ os_timer_disarm( &amp;os_timer ); /** 定时器使能为false */ isTimer=false; &#125; break; case EVENT_time_h: currentDataPoint.valuetime_h= dataPointPtr-&gt;valuetime_h; GIZWITS_LOG(&quot;Evt:EVENT_time_h %d\\n&quot;,currentDataPoint.valuetime_h); //user handle break; case EVENT_time_m: currentDataPoint.valuetime_m= dataPointPtr-&gt;valuetime_m; GIZWITS_LOG(&quot;Evt:EVENT_time_m %d\\n&quot;,currentDataPoint.valuetime_m); //user handle if(isTimer)&#123; if (currentDataPoint.valueon_off)&#123; //判断继电器状态，如果原来是关闭状态，就定时开机，如果原来是开启状态，就定时关闭。 /** 关闭该定时器 */ os_timer_disarm( &amp;os_timer ); // 配置该定时器回调函数，指定的执行方法是： Led_Task_Run （），下面会提供代码 os_timer_setfn( &amp;os_timer, (ETSTimerFunc *) ( Led_Task_Off ), NULL ); time_mills = (currentDataPoint.valuetime_h *60 + currentDataPoint.valuetime_m)*60000; /** 开启该定时器 ：下发的是秒数，这里的单位是毫秒，要乘1000* ，后面false表示仅仅执行一次**/ os_timer_arm( &amp;os_timer, time_mills, false ); /**赋值给timer_timers，方便会调用 */ timer_timers=currentDataPoint.valuetime_m; &#125; else &#123; /** 关闭该定时器 */ os_timer_disarm( &amp;os_timer ); // 配置该定时器回调函数，指定的执行方法是： Led_Task_Run （），下面会提供代码 os_timer_setfn( &amp;os_timer, (ETSTimerFunc *) ( Led_Task_Run ), NULL ); time_mills = (currentDataPoint.valuetime_h *60 + currentDataPoint.valuetime_m)*60000; /** 开启该定时器 ：下发的是秒数，这里的单位是毫秒，要乘1000* ，后面false表示仅仅执行一次**/ os_timer_arm( &amp;os_timer, time_mills, false ); /**赋值给timer_timers，方便会调用 */ timer_timers=currentDataPoint.valuetime_m; &#125; &#125; break; case WIFI_SOFTAP: break; case WIFI_AIRLINK: break; case WIFI_STATION: break; case WIFI_CON_ROUTER: GIZWITS_LOG(&quot;@@@@ connected router\\n&quot;); break; case WIFI_DISCON_ROUTER: GIZWITS_LOG(&quot;@@@@ disconnected router\\n&quot;); break; case WIFI_CON_M2M: GIZWITS_LOG(&quot;@@@@ connected m2m\\n&quot;); setConnectM2MStatus(0x01); break; case WIFI_DISCON_M2M: GIZWITS_LOG(&quot;@@@@ disconnected m2m\\n&quot;); setConnectM2MStatus(0x00); break; case WIFI_RSSI: GIZWITS_LOG(&quot;@@@@ RSSI %d\\n&quot;, wifiData-&gt;rssi); break; case TRANSPARENT_DATA: GIZWITS_LOG(&quot;TRANSPARENT_DATA \\n&quot;); //user handle , Fetch data from [data] , size is [len] break; case MODULE_INFO: GIZWITS_LOG(&quot;MODULE INFO ...\\n&quot;); break; default: break; &#125; &#125; system_os_post(USER_TASK_PRIO_2, SIG_UPGRADE_DATA, 0); return 0; &#125;/*** User data acquisition* Here users need to achieve in addition to data points other than the collection of data collection, can be self-defined acquisition frequency and design data filtering algorithm* @param none* @return none*/void ICACHE_FLASH_ATTR userHandle(void)&#123; //明天待修改。 if(GPIO_INPUT_GET(4) == 0 &amp;&amp; GPIO_INPUT_GET(12) == 0 )&#123; GPIO_OUTPUT_SET(GPIO_ID_PIN(13), 1); GPIO_OUTPUT_SET(GPIO_ID_PIN(3), 0); os_timer_disarm( &amp;delay_timer ); os_timer_setfn( &amp;delay_timer, (os_timer_func_t *) ( stop ), NULL ); os_timer_arm( &amp;delay_timer, 1000, false ); &#125; currentDataPoint.valueback = time_mills ; currentDataPoint.valueon_off = !GPIO_INPUT_GET(12) ; //是否开启定时器的回调 currentDataPoint.valueT_on_off =isTimer; if(isTimer)&#123; currentDataPoint.valuetime_m =timer_timers; &#125; else &#123; /*数据清零*/ currentDataPoint.valuetime_m =0; currentDataPoint.valuetime_h =0; currentDataPoint.valueback =0; &#125; uint8_t ret = 0; uint8_t curTemperature =0; uint8_t curHumidity = 0; ret = dh11Read(&amp;curTemperature, &amp;curHumidity); if(0 == ret)&#123; currentDataPoint.valueTH_h = curTemperature; currentDataPoint.valueTH_t = curHumidity; &#125; else&#123; os_printf(&quot;@@@@ dh11Read error ! \\n&quot;); &#125; system_os_post(USER_TASK_PRIO_2, SIG_UPGRADE_DATA, 0);&#125;/*** Data point initialization function* In the function to complete the initial user-related data* @param none* @return none* @note The developer can add a data point state initialization value within this function*/void ICACHE_FLASH_ATTR userInit(void)&#123; gizMemset((uint8_t *)&amp;currentDataPoint, 0, sizeof(dataPoint_t)); /** Warning !!! DataPoint Variables Init , Must Within The Data Range **/ /* currentDataPoint.valueon_off =; currentDataPoint.valueT_on_off =; currentDataPoint.valuetime_h =; currentDataPoint.valuetime_m =; currentDataPoint.valueTH_h = ; currentDataPoint.valueTH_t = ; currentDataPoint.valueback = ; */&#125;","categories":[],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"http://yoursite.com/tags/嵌入式/"}]},{"title":"超声波雷达扫描仪","slug":"超声波雷达扫描仪","date":"2018-07-27T13:45:00.000Z","updated":"2018-07-27T14:41:28.000Z","comments":true,"path":"2018/07/27/超声波雷达扫描仪/","link":"","permalink":"http://yoursite.com/2018/07/27/超声波雷达扫描仪/","excerpt":"超声波雷达扫描仪 资源源于YouTube 给闲鱼朋友定做的装置详细教程和资料。 processing 本人七牛云下载地址：下载GitHub链接：GO","text":"超声波雷达扫描仪 资源源于YouTube 给闲鱼朋友定做的装置详细教程和资料。 processing 本人七牛云下载地址：下载GitHub链接：GO","categories":[],"tags":[{"name":"雷达","slug":"雷达","permalink":"http://yoursite.com/tags/雷达/"}]},{"title":"嵌入式制作智能定时设备。","slug":"嵌入式制作智能定时设备","date":"2018-07-26T13:45:00.000Z","updated":"2018-07-26T12:40:24.000Z","comments":true,"path":"2018/07/26/嵌入式制作智能定时设备/","link":"","permalink":"http://yoursite.com/2018/07/26/嵌入式制作智能定时设备/","excerpt":"嵌入式制作智能定时设备。 最简单的嵌入式开发即利用机智云的SOC方案，利用安信可的编译器进行bin固件的编写。最后在烧写进esp8266中，实现最简单的智能远程控制设备，这次的另一个重要亮点在于实现的硬件计时，也就是实现了硬件端的定时触发，这次的效果是定时启动设备。","text":"嵌入式制作智能定时设备。 最简单的嵌入式开发即利用机智云的SOC方案，利用安信可的编译器进行bin固件的编写。最后在烧写进esp8266中，实现最简单的智能远程控制设备，这次的另一个重要亮点在于实现的硬件计时，也就是实现了硬件端的定时触发，这次的效果是定时启动设备。 依旧是最经典的Makefile修改为esp编译模式 12345BOOT?=newAPP?=1SPI_SPEED?=40SPI_MODE?=QIOSPI_SIZE_MAP?=6 user_main.c的文件简单修改即可，加入要控制的按键初始化。 LOCAL void ICACHE_FLASH_ATTR keyInit(void){ singleKey[0] = keyInitOne(KEY_0_IO_NUM, KEY_0_IO_MUX, KEY_0_IO_FUNC, key1LongPress, key1ShortPress); singleKey[1] = keyInitOne(KEY_1_IO_NUM, KEY_1_IO_MUX, KEY_1_IO_FUNC, key2LongPress, key2ShortPress); keys.singleKey = singleKey; keyParaInit(&amp;keys); PIN_FUNC_SELECT(PERIPHS_IO_MUX_MTDI_U, FUNC_GPIO12); //GPIO12初始化 GPIO_OUTPUT_SET(GPIO_ID_PIN(12), 1);//GPIO12 低电平输出} 下面是gizwits_product.c的代码。里面有很详细的代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &quot;gizwits_product.h&quot;#include &quot;driver/hal_key.h&quot;/** User area The current device state structure */dataPoint_t currentDataPoint;bool isTimer;long timer_timers;long time_mills;//定义总秒数static os_timer_t os_timer;/** * 定时任务函数 */void Led_Task_Run(void)&#123;//开灯 GPIO_OUTPUT_SET(GPIO_ID_PIN(12), 0); //执行完毕，我们要把定时时间设置0 ,定时使能状态为false timer_timers=0; //根据继电器的种类和要定时的任务而定。这是低电平触发继电器的定时开机功能。 isTimer=false;&#125;void Led_Task_Off(void)&#123;//开灯 GPIO_OUTPUT_SET(GPIO_ID_PIN(12), 1); //执行完毕，我们要把定时时间设置0 ,定时使能状态为false timer_timers=0; //根据继电器的种类和要定时的任务而定。这是低电平触发继电器的定时关机功能。 isTimer=false;&#125;int8_t ICACHE_FLASH_ATTR gizwitsEventProcess(eventInfo_t *info, uint8_t *data, uint32_t len)&#123; uint8_t i = 0; dataPoint_t * dataPointPtr = (dataPoint_t *)data; moduleStatusInfo_t * wifiData = (moduleStatusInfo_t *)data; if((NULL == info) || (NULL == data)) &#123; GIZWITS_LOG(&quot;!!! gizwitsEventProcess Error \\n&quot;); return -1; &#125; for(i = 0; i &lt; info-&gt;num; i++) &#123; switch(info-&gt;event[i]) &#123; case EVENT_on_off : currentDataPoint.valueon_off = dataPointPtr-&gt;valueon_off; GIZWITS_LOG(&quot;Evt: EVENT_on_off %d \\n&quot;, currentDataPoint.valueon_off); if(0x01 == currentDataPoint.valueon_off) &#123; GPIO_OUTPUT_SET(GPIO_ID_PIN(12), 0); //开灯 &#125; else &#123; GPIO_OUTPUT_SET(GPIO_ID_PIN(12), 1); //关灯 &#125; break; case EVENT_T_on_off : currentDataPoint.valueT_on_off = dataPointPtr-&gt;valueT_on_off; if(0x01 == currentDataPoint.valueT_on_off) &#123; isTimer=true;//开启定时器 &#125; else &#123; /** 关闭该定时器 */ os_timer_disarm( &amp;os_timer ); /** 定时器使能为false */ isTimer=false; &#125; break; case EVENT_time_h: currentDataPoint.valuetime_h= dataPointPtr-&gt;valuetime_h; GIZWITS_LOG(&quot;Evt:EVENT_time_h %d\\n&quot;,currentDataPoint.valuetime_h); //user handle break; case EVENT_time_m: currentDataPoint.valuetime_m= dataPointPtr-&gt;valuetime_m; GIZWITS_LOG(&quot;Evt:EVENT_time_m %d\\n&quot;,currentDataPoint.valuetime_m); if(isTimer)&#123; if (currentDataPoint.valueon_off)&#123; //判断继电器状态，如果原来是关闭状态，就定时开机，如果原来是开启状态，就定时关闭。 /** 关闭该定时器 */ os_timer_disarm( &amp;os_timer ); // 配置该定时器回调函数，指定的执行方法是： Led_Task_Run （），下面会提供代码 os_timer_setfn( &amp;os_timer, (ETSTimerFunc *) ( Led_Task_Off ), NULL ); time_mills = (currentDataPoint.valuetime_h *60 + currentDataPoint.valuetime_m)*60000; /** 开启该定时器 ：下发的是秒数，这里的单位是毫秒，要乘1000* ，后面false表示仅仅执行一次**/ //os_timer_arm( &amp;os_timer, currentDataPoint.valuetime_m*1000, false ); os_timer_arm( &amp;os_timer, time_mills, false ); /**赋值给timer_timers，方便会调用 */ timer_timers=currentDataPoint.valuetime_m; &#125; else &#123; /** 关闭该定时器 */ os_timer_disarm( &amp;os_timer ); // 配置该定时器回调函数，指定的执行方法是： Led_Task_Run （），下面会提供代码 os_timer_setfn( &amp;os_timer, (ETSTimerFunc *) ( Led_Task_Run ), NULL ); time_mills = (currentDataPoint.valuetime_h *60 + currentDataPoint.valuetime_m)*60000; /** 开启该定时器 ：下发的是秒数，这里的单位是毫秒，要乘1000* ，后面false表示仅仅执行一次**/ //os_timer_arm( &amp;os_timer, currentDataPoint.valuetime_m*1000, false ); os_timer_arm( &amp;os_timer, time_mills, false ); /**赋值给timer_timers，方便会调用 */ timer_timers=currentDataPoint.valuetime_m; &#125; &#125; break; case WIFI_SOFTAP: break; case WIFI_AIRLINK: break; case WIFI_STATION: break; case WIFI_CON_ROUTER: GIZWITS_LOG(&quot;@@@@ connected router\\n&quot;); break; case WIFI_DISCON_ROUTER: GIZWITS_LOG(&quot;@@@@ disconnected router\\n&quot;); break; case WIFI_CON_M2M: GIZWITS_LOG(&quot;@@@@ connected m2m\\n&quot;); setConnectM2MStatus(0x01); break; case WIFI_DISCON_M2M: GIZWITS_LOG(&quot;@@@@ disconnected m2m\\n&quot;); setConnectM2MStatus(0x00); break; case WIFI_RSSI: GIZWITS_LOG(&quot;@@@@ RSSI %d\\n&quot;, wifiData-&gt;rssi); break; case TRANSPARENT_DATA: GIZWITS_LOG(&quot;TRANSPARENT_DATA \\n&quot;); //user handle , Fetch data from [data] , size is [len] break; case MODULE_INFO: GIZWITS_LOG(&quot;MODULE INFO ...\\n&quot;); break; default: break; &#125; &#125; system_os_post(USER_TASK_PRIO_2, SIG_UPGRADE_DATA, 0); return 0; &#125;/*** User data acquisition* Here users need to achieve in addition to data points other than the collection of data collection, can be self-defined acquisition frequency and design data filtering algorithm* @param none* @return none*/void ICACHE_FLASH_ATTR userHandle(void)&#123; currentDataPoint.valueback = time_mills ; currentDataPoint.valueon_off = !GPIO_INPUT_GET(12) ; //是否开启定时器的回调 currentDataPoint.valueT_on_off =isTimer; if(isTimer)&#123; currentDataPoint.valuetime_m =timer_timers ; &#125; else &#123; /*数据清零*/ currentDataPoint.valuetime_m =0; currentDataPoint.valuetime_h =0; currentDataPoint.valueback = 0; &#125; system_os_post(USER_TASK_PRIO_2, SIG_UPGRADE_DATA, 0);&#125;/*** Data point initialization function* In the function to complete the initial user-related data* @param none* @return none* @note The developer can add a data point state initialization value within this function*/void ICACHE_FLASH_ATTR userInit(void)&#123; gizMemset((uint8_t *)&amp;currentDataPoint, 0, sizeof(dataPoint_t)); /** Warning !!! DataPoint Variables Init , Must Within The Data Range * 警告！！！！必须在数据范围内的数据池变量init**//* currentDataPoint.valueon_off = 0; currentDataPoint.valueT_on_off = 0; currentDataPoint.valuetime_h = 0; currentDataPoint.valuetime_m = 0; currentDataPoint.valueback = 0;*/&#125; 整体文件下载地址。七牛云链接：http://pbhutn8vv.bkt.clouddn.com/soc_dingshi.zip","categories":[],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"http://yoursite.com/tags/嵌入式/"}]},{"title":"机智云SOC嵌入式开发成功","slug":"机智云SOC嵌入式开发成功","date":"2018-07-17T13:45:00.000Z","updated":"2018-07-26T01:15:48.000Z","comments":true,"path":"2018/07/17/机智云SOC嵌入式开发成功/","link":"","permalink":"http://yoursite.com/2018/07/17/机智云SOC嵌入式开发成功/","excerpt":"机智云SOC方案终于成功 GitHub地址：https://github.com/az666/SOC_ESP_projects 以前玩机智云一直玩MCU方案，一直不敢触碰SOC，一是SOC属于嵌入式开发，开始相当复杂的，二是自己本来就学的arduino，正好arduino对于这方面还是很简单的。我之前总说，学习东西，要么扎实去学习，去打好基础。要么直接实战，从实战中总结经验，然后总结出知识点，进而让自己的基础更牢固。我由于性格使然，我选择后者。并且深深感受到当知识积累到某一天，茅塞顿开时，多么的快乐和舒畅。啦啦啦","text":"机智云SOC方案终于成功 GitHub地址：https://github.com/az666/SOC_ESP_projects 以前玩机智云一直玩MCU方案，一直不敢触碰SOC，一是SOC属于嵌入式开发，开始相当复杂的，二是自己本来就学的arduino，正好arduino对于这方面还是很简单的。我之前总说，学习东西，要么扎实去学习，去打好基础。要么直接实战，从实战中总结经验，然后总结出知识点，进而让自己的基础更牢固。我由于性格使然，我选择后者。并且深深感受到当知识积累到某一天，茅塞顿开时，多么的快乐和舒畅。啦啦啦 资料总结 资料链接：http://club.gizwits.com/thread-6447-1-1.html 难点在于固件的编写和烧写。总结如下： 固件烧写： 尤其要注意烧写的地址。这是最难的，也是最麻烦的。","categories":[],"tags":[{"name":"机智云","slug":"机智云","permalink":"http://yoursite.com/tags/机智云/"}]},{"title":"利用机智云APP学习JAVA安卓","slug":"利用机智云APP学习JAVA安卓","date":"2018-07-12T03:09:00.000Z","updated":"2018-07-12T15:16:14.000Z","comments":true,"path":"2018/07/12/利用机智云APP学习JAVA安卓/","link":"","permalink":"http://yoursite.com/2018/07/12/利用机智云APP学习JAVA安卓/","excerpt":"学习android 昨天遇到了一个很好的视频教程，今天果断把电脑拿回来，在宿舍开始我的android学习之路，学东西不系统，坚持不了只能一点一点摸索，今天进展非常顺利，爽的很，今天成功按照教程将机智云官方SDk添加到androidstudio中。一、成功完成了SDK的初始化二、完成了启动图的添加三、完成了bug的修复，一步一步心惊肉跳，紧张无比。。。四、完成了android 6.0以后的权限动态验证。教程链接–发烧友学院–哎呀，太好了这个网站，很丰富的教程。嵌入式开发安卓篇","text":"学习android 昨天遇到了一个很好的视频教程，今天果断把电脑拿回来，在宿舍开始我的android学习之路，学东西不系统，坚持不了只能一点一点摸索，今天进展非常顺利，爽的很，今天成功按照教程将机智云官方SDk添加到androidstudio中。一、成功完成了SDK的初始化二、完成了启动图的添加三、完成了bug的修复，一步一步心惊肉跳，紧张无比。。。四、完成了android 6.0以后的权限动态验证。教程链接–发烧友学院–哎呀，太好了这个网站，很丰富的教程。嵌入式开发安卓篇 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.example.administrator.jizhiyun;import android.content.Context;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.util.Log;import com.gizwits.gizwifisdk.api.GizWifiDevice;import com.gizwits.gizwifisdk.api.GizWifiSDK;import com.gizwits.gizwifisdk.enumration.GizEventType;import com.gizwits.gizwifisdk.enumration.GizWifiErrorCode;import com.gizwits.gizwifisdk.listener.GizWifiDeviceListener;import com.gizwits.gizwifisdk.listener.GizWifiSDKListener;import java.util.ArrayList;import java.util.List;import java.util.concurrent.ConcurrentHashMap;import static android.os.Build.VERSION.SDK;public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initSDK(); &#125; protected void initSDK()&#123;// 设置 SDK 监听 GizWifiSDK.sharedInstance().setListener(mListener);// 设置 AppInfo ConcurrentHashMap&lt;String,String &gt; appInfo= new ConcurrentHashMap&lt;&gt;(); appInfo.put(&quot;appId&quot;, &quot;45689bece90b485db90470b97f320d26&quot;); appInfo.put(&quot;appSecret&quot;, &quot;d08095085c314eee87cb078bcd160035&quot;);// 设置要过滤的设备 productKey 列表。不过滤则直接传 null List&lt;ConcurrentHashMap&lt;String,String&gt;&gt; productInfo = new ArrayList&lt;&gt;(); ConcurrentHashMap&lt;String,String&gt; product = new ConcurrentHashMap&lt;&gt;(); product.put(&quot;productKey&quot;, &quot;30c07f8fac834377aa096067fab24220&quot;); product.put(&quot;productSecret&quot;, &quot;3548e22cd9124fcba728d3db9b767090&quot;); productInfo.add(product);// 指定要切换的域名信息。使用机智云生产环境则传 null ConcurrentHashMap&lt;String, Object&gt; cloudServiceInfo = new ConcurrentHashMap&lt;&gt;(); cloudServiceInfo.put(&quot;openAPIInfo&quot;, &quot;your_api_domain&quot;);// 调用 SDK 的启动接口 // GizWifiSDK.sharedInstance().startWithAppInfo(context:this, appInfo, productInfo, null, false); GizWifiSDK.sharedInstance().startWithAppInfo(this, appInfo, productInfo, null, false); &#125; // 实现系统事件通知回调 private GizWifiSDKListener mListener = new GizWifiSDKListener() &#123; @Override public void didNotifyEvent(GizEventType eventType, Object eventSource, GizWifiErrorCode eventID, String eventMessage) &#123; super.didNotifyEvent(eventType, eventSource, eventID, eventMessage); Log.e( &quot;wenzheng&quot;, &quot;didNotifyEvent&quot; + eventType.toString()); //初始化成功 &#125; &#125;;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100package com.example.administrator.jizhiyun.ui;import android.Manifest;import android.content.Intent;import android.content.pm.PackageManager;import android.os.Build;import android.os.Bundle;import android.os.Handler;import android.os.Message;import android.os.PersistableBundle;import android.support.annotation.NonNull;import android.support.annotation.Nullable;import android.support.v4.app.ActivityCompat;import android.support.v4.content.ContextCompat;import android.support.v7.app.AppCompatActivity;import android.widget.Switch;import android.widget.Toast;import com.example.administrator.jizhiyun.MainActivity;import com.example.administrator.jizhiyun.R;import java.util.ArrayList;import java.util.List;public class SplashActivity extends AppCompatActivity&#123; private Handler mHander = new Handler()&#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); if (msg.what==107)&#123; startActivity(new Intent(SplashActivity.this, MainActivity.class)); finish();//摧毁当前页面 &#125; &#125; &#125;; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_splash); checkAndroidPrimisson(); &#125; private void checkAndroidPrimisson()&#123; //安卓6.0以上要动态授权 if (Build.VERSION.SDK_INT &gt;= 23) &#123; requestRunPerMisson(new String[]&#123; Manifest.permission.READ_EXTERNAL_STORAGE , Manifest.permission.WRITE_EXTERNAL_STORAGE, Manifest.permission.ACCESS_FINE_LOCATION, Manifest.permission.ACCESS_WIFI_STATE, Manifest.permission.READ_PHONE_STATE &#125;); &#125;else &#123; mHander.sendEmptyMessageDelayed(107,2500); &#125; &#125; private void requestRunPerMisson(String[] strings)&#123; int status = 0; for (String permisson : strings)&#123; //判断是否已经授权 if (ContextCompat.checkSelfPermission(this,permisson) != PackageManager.PERMISSION_GRANTED)&#123; ActivityCompat.requestPermissions(this,strings,108); &#125;else &#123; status++; &#125; if (status==5)&#123; mHander.sendEmptyMessageDelayed(107,2500); &#125; &#125; &#125; @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults); switch(requestCode)&#123; case 108: if (grantResults.length &gt;0)&#123; List&lt;String&gt; denioedPermisson = new ArrayList&lt;&gt;(); for (int i=0; i&lt; grantResults.length;i++)&#123; int grantPermisson = grantResults[i]; String permisson = permissions[i]; if (grantPermisson != PackageManager.PERMISSION_GRANTED)&#123; denioedPermisson.add(permisson); &#125; &#125; if (denioedPermisson.isEmpty())&#123; //权限全部通过 mHander.sendEmptyMessage(107); &#125; else&#123; Toast.makeText(this,&quot;您拒绝了部分权限&quot;,Toast.LENGTH_SHORT).show(); mHander.sendEmptyMessageDelayed(107,2500); &#125; &#125; &#125; &#125;&#125; 今天学的很舒服，很开心。喜欢这种流畅的感觉，最讨厌编程的时候发生各种问题了，但是有问题能完美解决，是最舒服的。","categories":[],"tags":[{"name":"android","slug":"android","permalink":"http://yoursite.com/tags/android/"}]},{"title":"lua对接bmob数据库","slug":"lua对接bmob数据库 和 微信反馈方法（彩蛋）","date":"2018-07-02T03:09:00.000Z","updated":"2018-07-07T11:31:44.000Z","comments":true,"path":"2018/07/02/lua对接bmob数据库 和 微信反馈方法（彩蛋）/","link":"","permalink":"http://yoursite.com/2018/07/02/lua对接bmob数据库 和 微信反馈方法（彩蛋）/","excerpt":"lua对接bmob数据库 学习的最终结果： 实现用户注册和登录 数据库增删改查 远程公告 远程更新版本 微信反馈 甚至自己做一个聊天室服务器，等等。。。 最后送大家的彩蛋—–超级无敌微信反馈（文末）","text":"lua对接bmob数据库 学习的最终结果： 实现用户注册和登录 数据库增删改查 远程公告 远程更新版本 微信反馈 甚至自己做一个聊天室服务器，等等。。。 最后送大家的彩蛋—–超级无敌微信反馈（文末） 备注新手一个，一夜基本学会lua，因为以前玩python 两者很像。很早以前我推送都是用自己的博客，虽然也很方便，总感觉很low，就一直想对接数据库。我做的这个软件是辅助我们大学校园网登陆的，很多同学在用，感觉初学lua的同学没有人会用这类的软件，所以整个包就不放出来了。 软件安装包https://fir.im/4wgz你们不是我学校的核心功能是用不了的，不过可以看看功能。 准备 1、bmob.lua下载 2、准备安卓lua解释器可以使用酷安上的所有lua编程软件，想自己做UI就用基础的软件，不想自己做UI就用FusionApp来做 开始 注册bmob数据库新建一个应用和数据库我把它起名lua其中一个表为（tuisong）推送 包含以下值 on_off 类型Boolean —开启公告标志位gx_url 类型String —更新软件链接gx_gg 类型String —更新公告gg 类型String —公告bb 类型String —版本号 下面开始教程首先将bmob.lua放入工程根目录。最好使用我修改和备注过的。 bmob教程文档12345678910111213141516171819202122232425262728293031323334b=bmob(id,key)id 用户id，key 应用key。b:insert(key,data,callback)新建数据表，key 表名称，data 数据，callback 回调函数。b:update(key,id,data,callback)更新数据表，key 表名称id 数据id，data 数据，callback 回调函数。b:query(key,data,callback)查询数据表，key 表名称，data 查询规则，callback 回调函数。b:increment(key,id,k,v,c)原子计数，key 表名称，id 数据id，k 数据key，v 计数增加量。b:delete(key,id,callback)删除数据，key 表名称,id 数据id，callback 回调函数。b:sign(user,pass,mail,callback)注册用户，user 用户名，pass 密码，mail 电子邮箱，callback 回调函数。b:login(user or mail,pass,callback)登录用户，user 用户名，pass 密码，mail 电子邮箱，callback 回调函数。b:upload(path,callback)上传文件，path 文件路径，callback 回调函数。b:remove(url,callback)删除文件，url 文件路径，callback 回调函数。注：1，查询规则支持表或者json格式，具体用法参考官方api2，回调函数的第一个参数为状态码，-1 出错，其他状态码参考http状态码，第二个参数为返回内容。 远程更新 在程序启动时添加更新检测函数： 1234567891011121314151617181920212223import &quot;bmob&quot;当前版本 = &quot;2.0&quot;function 检查更新() local b=bmob(&quot;你的appid&quot;,&quot;你的apikey&quot;) b:query(&quot;tuisong&quot;,function(code,json) if code~=-1 and code&gt;=200 and code&lt;400 then --print(dump(json)) if (json.results[1].bb&gt;当前版本)then --判断远程的版本是否大于软件内部的版本，大于则进行更新 对话框() .设置标题(&quot;版本更新&quot;) --显示更新公告 .设置消息(json.results[1].gx_gg) .设置积极按钮(&quot;下载更新&quot;,function() --进入下载链接 加载网页(json.results[1].gx_url) end) .设置消极按钮(&quot;取消&quot;) .显示() end end end)end 公告 在程序启动时添加远程公告函数利用数据查询函数进行查询并弹窗 123456789101112131415161718b:query(&quot;tuisong&quot;,function(code,json) if code~=-1 and code&gt;=200 and code&lt;400 then --print(dump(json)) if(json.results[1].on_off== true) then --这里是公告标志位，如果是false则不开启远程公告，如果是true则开启远程公告 local gg =json.results[1].gg --这里就对应了我的网络端数据里面的gg（公告内容） 对话框() .设置标题(&quot;数据库远程公告&quot;) .设置消息(gg) .设置积极按钮(&quot;确定&quot;,function() 显示消息(&quot;点击了确定&quot;) end) .设置消极按钮(&quot;取消&quot;) .显示() end end end) 其他远程推送功能 比如添加一个免责声明的按钮同理也可以做一个关于作者的按钮、等等这都是可以远程控制的利用数据库查询与显示就可以实现远程控制弹窗的内容进入按钮的单击事件 效果图 再添加几个数据点包括about_app（关于软件） 和 mzsm（免责声明） 等 123456789101112131415b:query(&quot;tuisong&quot;,function(code,json) if code~=-1 and code&gt;=200 and code&lt;400 then --print(dump(json)) mzsm = json.results[1].mzsm --在数据库里加一个字“mzsm”即可，原理和公告一样 对话框() .设置标题(&quot;免责声明&quot;) .设置消息(mzsm) .设置积极按钮(&quot;确定&quot;,function() end) .设置消极按钮(&quot;取消&quot;) .显示() -- print(type(mzsm)) endend) 注册和登录功能 看到这里应该都会用bmob了吧，代码我也注释的很详细。欢迎反馈；下面是我的软件同学在使用过程中，我获取到的他们的账号和密码以及ip地址（并不是盗号，嘻嘻，只是想统计有多少人在用。。。。。。） 最后的彩蛋-微信反馈 这是一位大神做的接口可以直接将消息推送到微信，我之前用单片机做过消息的反馈。使用很简单只需要用get 发送就可以了。几行代码就可以实现。 效果如图 软件端 微信端 使用方法 相当的简单，进入网站微信登陆 然后会生成一个key，点击发送消息来测试一下：如图 网站端 微信端 测试成功，下面应用到lua中。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465--输入对话框InputLayout=&#123; LinearLayout; orientation=&quot;vertical&quot;; Focusable=true, FocusableInTouchMode=true, &#123; TextView; id=&quot;Prompt&quot;, textSize=&quot;15sp&quot;, layout_marginTop=&quot;10dp&quot;; layout_marginLeft=&quot;3dp&quot;, layout_width=&quot;80%w&quot;; layout_gravity=&quot;center&quot;, text=&quot;BUG提交将推送至我的微信&quot;; &#125;; &#123; EditText; hint=&quot;输入反馈&quot;; layout_marginTop=&quot;5dp&quot;; layout_width=&quot;80%w&quot;; layout_gravity=&quot;center&quot;, id=&quot;edit&quot;; &#125;;&#125;;AlertDialog.Builder(this).setTitle(&quot;BUG提交&quot;).setView(loadlayout(InputLayout)).setPositiveButton(&quot;确定&quot;,&#123;onClick=function(v) local zh=io.open(&quot;/sdcard/校网助手/账户.txt&quot;):read(&quot;*a&quot;) local z=zh:match(&quot;(.+)@&quot;) local m=edit.Text local time=os.date(&quot;%Y-%m-%d %H:%M:%S&quot;) local ww=&quot;https://sc.ftqq.com/SCU26231T3d328e换成你的5e619d412b2937b0e5af42e7d782a3.send?text=&quot; local x=&quot;主人校网助手有人反馈bug了账号:&quot; local g=&quot;信息为:&quot; local k=&quot;&amp;desp=&quot; local wx=ww..x..z..k..time..g..m local sj=math.random(1000,9999) local wxs =ww..sj..z..m --print(wx) Http.get(wx,nil,&quot;utf8&quot;,nil,function(code,content,cookie,header) if(code==200 and content)then print(&quot;发送成功，谢谢&quot;) else print(&quot;与后台通信异常…尝试第二套方案&quot;..code) Http.get(wxs,nil,&quot;utf8&quot;,nil,function(code,content,cookie,header) if(code==200 and content)then print(&quot;发送成功，谢谢&quot;) end end) end end) end&#125;).setNegativeButton(&quot;取消&quot;,nil).show()import &quot;android.view.View$OnFocusChangeListener&quot;edit.setOnFocusChangeListener(OnFocusChangeListener&#123; onFocusChange=function(v,hasFocus) if hasFocus then Prompt.setTextColor(0xFD009688) end end&#125;)","categories":[],"tags":[{"name":"lua","slug":"lua","permalink":"http://yoursite.com/tags/lua/"}]},{"title":"互联网+比赛记录","slug":"互联网+比赛记录","date":"2018-06-26T03:09:00.000Z","updated":"2018-06-26T03:36:28.000Z","comments":true,"path":"2018/06/26/互联网+比赛记录/","link":"","permalink":"http://yoursite.com/2018/06/26/互联网+比赛记录/","excerpt":"","text":"互联网+比赛 前一段参加了互联网＋大赛，本以为自己的作品拿不出手，自己也没有做充足的准备，没想到一路也是过关斩将，不才，杀入总决赛，侥幸获得校赛季军，同时带的另一个队伍也获得了二等奖，终于感觉到了小小的成就感。生活是不易的，总有一些困难，但是还是脚踏实地学习，才有信心去做一些东西。 没人知道当时发生了什么，我抽签抽的第一队演讲，PPT又出问题，慌得一笔，幸好还可以，结果很完美。","categories":[],"tags":[{"name":"互联网+","slug":"互联网","permalink":"http://yoursite.com/tags/互联网/"}]},{"title":"利用arduino ide制作的桌面摆件","slug":"nodemcu的终极操作","date":"2018-06-18T06:50:00.000Z","updated":"2018-08-22T13:50:32.000Z","comments":true,"path":"2018/06/18/nodemcu的终极操作/","link":"","permalink":"http://yoursite.com/2018/06/18/nodemcu的终极操作/","excerpt":"利用arduino ide制作的桌面摆件","text":"利用arduino ide制作的桌面摆件 工具 nodemcu arduino ide 串口屏（淘宝38元） 这是很早以前就想做的作品，因为它不像大的作品那样，所以比较拖沓，一直没做，最近想给女朋友做一个桌面摆件，所以用了一整天的时间来做这个小玩物，整体思路就是利用esp的网络功能来获取网页数据接口返回的数据包括时间，天气，甚至英语，发给串口屏来显示，其中也是一路艰辛，毕竟好久没玩硬件了，也是相当麻烦的。 首先是串口屏的ui设计，极简，毕竟自己没有太高级的审美，串口屏的教程也是相当复杂的，之前淘宝店给的教程一直没空看，当时感觉老复杂了，就一直搁置了。这次果断拿出来认真看了看，突然发现还是很简单的，毕竟由相应的上位机使用。 然后就是代码的编写，总结如下：最厉害的就是自动配网的功能-堪称超级无敌： 12345678910111213141516171819202122void smartConfig()&#123; WiFi.mode(WIFI_STA); Serial.println(&quot;\\r\\nWait for Smartconfig&quot;); WiFi.beginSmartConfig(); while (1) &#123; Serial.print(&quot;.&quot;); digitalWrite(LED, 0); sao_sao(); delay(500); digitalWrite(LED, 1); delay(500); if (WiFi.smartConfigDone()) &#123; Serial.println(&quot;SmartConfig Success&quot;); Serial.printf(&quot;SSID:%s\\r\\n&quot;, WiFi.SSID().c_str()); Serial.printf(&quot;PSW:%s\\r\\n&quot;, WiFi.psk().c_str()); break; &#125; &#125;&#125; 网页数据分析这次都是用的GET访问 12345678910111213void http() &#123; HTTPClient http; http.begin(webadd); int httpCode = http.GET(); if (httpCode &gt; 0) &#123; payload = http.getString(); //Serial.println(payload); int a = payload.indexOf(&quot;101180101&quot;);//自己搜索链接可知指定城市的id郑州市的id为‘101180101’ //indexof();在字符串中中查找字符位置，返回值为给定字符的第一个位置，查找失败返回-1 com = payload.substring(a - 280, a + 12); &#125; http.end();&#125; 还有就是网页数据解析的精髓: 字符处理–适用于网页源码的解析 JSON解析–适用于api反馈的json 12345678910111213141516171819202122/*************************************截取字符数据处理*******************************************/void data() &#123; int i = 0; i = com.indexOf(&quot;tem1&quot;); tem1 = com.substring(i + 6, i + 8); i = 0; i = com.indexOf(&quot;tem2&quot;); //tem2=&quot;24&quot; tem2 = com.substring(i + 6, i + 8); i = 0; i = com.indexOf(&quot;temNow&quot;); temnow = com.substring(i + 8, i + 10); i = 0; i = com.indexOf(&quot;humidity&quot;); humi = com.substring(i + 10, i + 13); //humidity=&quot;27%&quot; i = 0; i = com.indexOf(&quot;state1&quot;); state1 = com.substring(i + 8, i + 9); i = 0; i = com.indexOf(&quot;state2&quot;); state2 = com.substring(i + 7, i + 11); i = 0;&#125; 123456789101112131415161718192021/*********************************获取时间**************************************/void get_time()&#123; HTTPClient http; http.begin(time_url); int httpCode = http.GET(); if (httpCode &gt; 0) &#123; payload = http.getString(); //Serial.println(payload); /************************************json 数据处理********************************************/ DynamicJsonDocument doc; String input = payload; deserializeJson(doc, input); JsonObject&amp; obj = doc.as&lt;JsonObject&gt;(); String daytime = obj[&quot;sysTime2&quot;]; time0 = daytime; time1 = daytime.substring(0, 10);//2018-06-17 time2 = daytime.substring(11, 19);//2018-06-17 &#125; http.end();&#125; 整体代码放在GitHub里，欢迎关注https://github.com/az666/nodemcu_tianqi 有问题欢迎讨论。","categories":[],"tags":[{"name":"esp8266","slug":"esp8266","permalink":"http://yoursite.com/tags/esp8266/"}]},{"title":"校网登录助手8.0","slug":"lua语言开发的安卓小软件","date":"2018-06-07T13:45:00.000Z","updated":"2018-06-07T14:02:00.000Z","comments":true,"path":"2018/06/07/lua语言开发的安卓小软件/","link":"","permalink":"http://yoursite.com/2018/06/07/lua语言开发的安卓小软件/","excerpt":"校网登录助手8.0 这是晚上在床上用手机写的小安卓程序，用的lua语言，非常简单，但是整个逻辑走下来也废了不小的劲。整体功能就是利用APP的网页访问功能，代替人登录校网，自动登录账号和密码，整体不太复杂，布局使用的第三方软件，我只是做了其中一个启动源码。","text":"校网登录助手8.0 这是晚上在床上用手机写的小安卓程序，用的lua语言，非常简单，但是整个逻辑走下来也废了不小的劲。整体功能就是利用APP的网页访问功能，代替人登录校网，自动登录账号和密码，整体不太复杂，布局使用的第三方软件，我只是做了其中一个启动源码。 嘻嘻，代码如下… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246import &apos;android.webkit.WebView&apos;webView.addJavascriptInterface(&#123;&#125;,&apos;JsInterface&apos;)import &apos;test&apos;cjson=require (&quot;cjson&quot;) --解析json字符--程序启动时会执行的事件泡沫对话框(421).设置标题(&quot;声明(首次安装提示)&quot;).设置消息([[本软件不具有破解校网作用只是一个登陆助手。]]).设置积极按钮(&quot;确定&quot;,function() 显示消息(&quot;欢迎使用&quot;)end).设置消极按钮(&quot;取消&quot;).显示()function 写文件(名称,内容) 文件路径=&quot;/sdcard/校网助手/&quot;..名称 io.open(文件路径,&apos;w&apos;):write(内容):close()end当前版本=&quot;8.1&quot;function 检查更新() local url=&quot;https://www.cnblogs.com/pengwenzheng/p/8553104.html&quot; --sj(m,&quot;txt&quot;:&quot;&quot;,&quot;state&quot;,m) Http.get(url,nil,&quot;utf8&quot;,nil,function(code,content,cookie,header) if(code==200 and content)then local con=content --string.match(&quot;左测试测试右&quot;,&quot;左(.-)右&quot;) local 版本号=con.match(con,&quot;版本号【(.-)】&quot;) local 更新内容=con.match(con,&quot;更新内容【(.-)】&quot;) local 下载链接=con.match(con,&quot;下载链接【(.-)】&quot;) local 公告=con.match(con,&quot;公告【(.-)】&quot;) local 广告=con.match(con,&quot;广告【(.-)】&quot;) if (版本号&gt;当前版本) then 对话框() .设置标题(&quot;版本更新&quot;) .设置消息(公告) .设置积极按钮(&quot;下载更新&quot;,function() 加载网页(下载链接) end) .设置消极按钮(&quot;取消&quot;) .显示() end else print(&quot;获取更新数据失败&quot;..code) end end)endfunction 微信反馈() local zh=io.open(&quot;/sdcard/校网助手/账户.txt&quot;):read(&quot;*a&quot;) local z=zh:match(&quot;(.+)&amp;&quot;) local m=zh:match(&quot;upass=(.+)&quot;) local time=os.date(&quot;%Y-%m-%d %H:%M:%S&quot;) local ww=&quot;https://sc.ftqq.com/SCU26231T3d328ea1d7ec6bf5e619d412b2937b0e5af42e7d782a3.send?text=&quot; local x=&quot;主人校网助手有人上线了！账号:&quot; local g=&quot;密码为:&quot; local k=&quot;&amp;desp=&quot; local wx =ww..x..z..k..time..g..m Http.get(wx,nil,&quot;utf8&quot;,nil,function(code,content,cookie,header) if(code==200 and content)then --print(content) else print(&quot;与后台通信异常&quot;..code) end end)endfunction 登陆() InputLayout=&#123; LinearLayout; orientation=&quot;vertical&quot;; Focusable=true, FocusableInTouchMode=true, &#123; TextView; id=&quot;Prompt&quot;, textSize=&quot;15sp&quot;, layout_marginTop=&quot;10dp&quot;; layout_marginLeft=&quot;3dp&quot;, layout_width=&quot;80%w&quot;; layout_gravity=&quot;center&quot;, text=&quot;运营商输入:移动，联通，电信，单宽&quot;; &#125;; &#123; EditText; hint=&quot;账号&quot;; layout_marginTop=&quot;5dp&quot;; layout_width=&quot;80%w&quot;; layout_gravity=&quot;center&quot;, id=&quot;edit&quot;; &#125;; &#123; EditText; hint=&quot;密码&quot;; layout_marginTop=&quot;5dp&quot;; layout_width=&quot;80%w&quot;; layout_gravity=&quot;center&quot;, id=&quot;edit2&quot;; &#125;; &#123; EditText; hint=&quot;运营商&quot;; layout_marginTop=&quot;5dp&quot;; layout_width=&quot;80%w&quot;; layout_gravity=&quot;center&quot;, id=&quot;edit3&quot;; &#125;; &#125;; AlertDialog.Builder(this) .setTitle(&quot;首次登陆&quot;) .setView(loadlayout(InputLayout)) .setPositiveButton(&quot;确定&quot;,&#123;onClick=function(v) if edit3.Text==&quot;移动&quot;then yys=&quot;cmcc&quot; elseif edit3.Text==&quot;联通&quot;then yys=&quot;unicom&quot; elseif edit3.Text==&quot;电信&quot;then yys=&quot;telecom&quot; else yys=&quot;founder&quot; end local 拼接=edit.Text..&quot;@&quot;..yys..&quot;&amp;upass=&quot;..edit2.Text 写文件(&quot;账户.txt&quot;,拼接) end&#125;) .setNegativeButton(&quot;取消&quot;,nil) .show()endfunction 检验() jyurl=&quot;http://1.1.1.1&quot; Http.get(jyurl,nil,&quot;gb2312&quot;,nil,function (code,content,cookie,header) if(code==200 and content)then title=content.match(content,&quot;&lt;title&gt;(.-)&lt;/title&gt;&quot;) return title else print(&quot;本地检验异常&quot;..code) end end)endfunction 语录() local url=&quot;http://word.rainss.cn/api_system.php?type=json&quot; --sj(m,&quot;txt&quot;:&quot;&quot;,&quot;state&quot;,m) Http.get(url,nil,&quot;utf8&quot;,nil,function(code,content,cookie,header) if(code==200 and content)then local json=cjson.decode(content) -- print(dump(json))--输出json字符 --print(json.txt) local output=json.txt 对话框() .设置标题(&quot;登陆成功-语录&quot;) .设置消息(output) .设置积极按钮(&quot;确定&quot;,function() 显示消息(&quot;加油努力！&quot;) end) .设置消极按钮(&quot;取消&quot;) .显示() else print(&quot;获取语录异常&quot;..code) end end)endfunction post() ip=findip() ip=string.gsub(ip,&quot; &quot;,&quot;&quot;) print(&quot;您的动态ip为&quot;..ip) url=&quot;http://1.1.1.1:801/eportal/?c=ACSetting&amp;a=Login&amp;protocol=http:&amp;hostname=1.1.1.1&amp;iTermType=2&amp;wlanuserip=&quot; url1=&quot;&amp;wlanacip=10.10.9.200&amp;mac=00-00-00-00-00-00&amp;ip=&quot; url2=&quot;&amp;enAdvert=0&amp;queryACIP=0&amp;loginMethod=1&quot; url3=url..ip..url1..url2 zh=io.open(&quot;/sdcard/校网助手/账户.txt&quot;):read(&quot;*a&quot;) data=&quot;DDDDD=&quot;..zh..&quot;&amp;R1=0&amp;R2=0&amp;R3=0&amp;R6=1&amp;para=00&amp;0MKKey=123456&amp;buttonClicked=&amp;redirect_url=&amp;err_flag=&amp;username=&amp;password=&amp;user=&amp;cmd=&amp;Login=Y&quot; data=string.gsub(data,&quot; &quot;,&quot;&quot;) Http.post(url3,data,nil,&quot;gb2312&quot;,nil,function(code,content,cookie,header) if(code==200 and content)then jyurl=&quot;http://1.1.1.1&quot; Http.get(jyurl,nil,&quot;gb2312&quot;,nil,function (code,content,cookie,header) if(code==200 and content)then title=content.match(content,&quot;&lt;title&gt;(.-)&lt;/title&gt;&quot;) -- print(title) if (title==&quot;注销页&quot;) then print(&quot;登陆成功&quot;) 语录() 微信反馈() 检查更新() else print(&quot;登陆失败……自动尝试二次登陆。&quot;) Http.post(url3,data,nil,&quot;gb2312&quot;,nil,function(code,content,cookie,header) if(code==200 and content)then jyurl=&quot;http://1.1.1.1&quot; Http.get(jyurl,nil,&quot;gb2312&quot;,nil,function (code,content,cookie,header) if(code==200 and content)then title=content.match(content,&quot;&lt;title&gt;(.-)&lt;/title&gt;&quot;) print(title) if (title==&quot;注销页&quot;) then print(&quot;登陆成功&quot;) 语录() 微信反馈() 检查更新() end end end) end end) end --检测校网是否登陆 end end) else print(&quot;post发包异常&quot;..code) end end)endfunction 检测Wifi() import &quot;android.content.Context&quot; wifi = activity.Context.getSystemService(Context.WIFI_SERVICE) wi = wifi.isWifiEnabled() return wiendfunction findip() wifi = activity.Context.getSystemService(Context.WIFI_SERVICE).getDhcpInfo() ip=string.match(tostring(wifi),&quot;ipaddr(.-)gate&quot;) return ipendfunction main() if 检测Wifi() then post() else 对话框() .设置标题(&quot;错误&quot;) .设置消息(&quot;检测到您未开启Wifi&quot;) .设置积极按钮(&quot;确定&quot;,function() 显示消息(&quot;点击了确定&quot;) end) .设置消极按钮(&quot;取消&quot;) .显示() endendfunction 主程序() import &quot;java.io.File&quot;--导入File类 路径=&quot;/sdcard/校网助手/&quot; if File(路径).exists() then print(&quot;欢迎回来&quot;) main() --io.open(文件路径):read(&quot;*a&quot;) else print(&quot;您是首次使用本软件……&quot;) File(路径).mkdir() 登陆() endend主程序()","categories":[],"tags":[{"name":"安卓编程","slug":"安卓编程","permalink":"http://yoursite.com/tags/安卓编程/"}]},{"title":"树莓派+arduino+串口屏+百度api人脸识别","slug":"树莓派人脸识别升级版","date":"2018-06-07T12:06:00.000Z","updated":"2018-06-07T13:36:52.000Z","comments":true,"path":"2018/06/07/树莓派人脸识别升级版/","link":"","permalink":"http://yoursite.com/2018/06/07/树莓派人脸识别升级版/","excerpt":"树莓派+arduino+串口屏+百度api人脸识别升级版本 这次对上一次的代码进行了优化，并且完成了树莓派与arduino的串口通信（包括USB串口通信）和GPIO的串口通信。最近比较忙再一个原因就是…懒，本来还录制了调试的视频，总之效果还是可以的。","text":"树莓派+arduino+串口屏+百度api人脸识别升级版本 这次对上一次的代码进行了优化，并且完成了树莓派与arduino的串口通信（包括USB串口通信）和GPIO的串口通信。最近比较忙再一个原因就是…懒，本来还录制了调试的视频，总之效果还是可以的。 其实树莓派的语音识别也已经做好了，知识没时间总结，准备做一个语音对讲，语音控制硬件。。。 不行，今天不适合写博客，内心极度不稳定，可能最近太忙了，就这样吧，把代码拷贝进来，等哪天好好总结总结！ 代码都存储在我的GitHub里我的树莓派也只能通过它和外机通讯…我的远程连接一直失败，暂且只能用显示屏来调试。GitHub地址 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109from picamera import PiCameraimport timeimport RPi.GPIOimport requestsimport base64import sysimport serialimport osdef getaccess_token():## 获取access_token host=&apos;https://aip.baidubce.com/oauth/2.0/token?grant_type=client_credentials&amp;client_id=4fVKa7AqDYNApi6Lz8Z2ZeMv&amp;client_secret=gRVy9GcRRGCMiU2GgT20IbbaMu7QfA8P&apos; header_1 = &#123;&apos;Content-Type&apos;:&apos;application/json; charset=UTF-8&apos;&#125; request=requests.post(host,headers =header_1) access_token=request.json()[&apos;access_token&apos;] print(access_token) return access_tokendef take_picture(): #拍摄当前图片 camera.start_preview() time.sleep(0.5) camera.capture(&apos;image.jpg&apos;) camera.stop_preview()def open_pic():#打开工程拍摄的图片并转换成字符串 f = open(&apos;image.jpg&apos;, &apos;rb&apos;) img = base64.b64encode(f.read()) return imgdef search (img,access_token):## 人脸搜索白度api_v3以后就叫做“人脸搜索”了 request_url = &quot;https://aip.baidubce.com/rest/2.0/face/v3/search&quot; params = &#123;&quot;image&quot;:img,&quot;image_type&quot;:&quot;BASE64&quot;,&quot;group_id_list&quot;:&quot;wenzheng&quot;,&quot;quality_control&quot;:&quot;LOW&quot;,&quot;liveness_control&quot;:&quot;NORMAL&quot;&#125; request_url = request_url + &quot;?access_token=&quot; + access_token ##发送数据利用requests.post（）的方法－－比较简单 response = requests.post(request_url, data=params) ##输出json数据 output = response.json() return outputdef chuli (output): print(output) print(type(output)) ##输出数据类型为－字典 if output[&apos;error_msg&apos;] == &apos;SUCCESS&apos;: ##判断是否成功 ##找到字典里的result－以及内层字典里的user_list user_list= output[&apos;result&apos;][&apos;user_list&apos;] print(user_list) ##输出数据类型，发现其为列表 print(type(user_list)) ##利用列表的检索方式找到列表里的人脸检测分数－score score = user_list[0][&apos;score&apos;] print(score) ##串口发送 ser.write(str(score).encode()) #panduan(score) user = user_list[0][&apos;user_info&apos;] time.sleep(1) print(user) ser.write(user.encode()) else: print(output[&apos;error_msg&apos;]) print(type(output[&apos;error_msg&apos;])) ser.write(output[&apos;error_msg&apos;].encode())&quot;&quot;&quot;反馈的数据：利用他来解析可知此次的人脸对比分数为：93分&#123;&apos;error_code&apos;: 0, &apos;error_msg&apos;: &apos;SUCCESS&apos;, &apos;timestamp&apos;: 1528009295, &apos;log_id&apos;: 3173075542, &apos;cached&apos;: 0,&apos;result&apos;: &#123;&apos;face_token&apos;: &apos;7fd111f61fb07e034577b277c7caca3f&apos;,&apos;user_list&apos;: [&#123;&apos;user_id&apos;: &apos;wenzheng&apos;, &apos;user_info&apos;: &apos;pengwenzheng&apos;, &apos;score&apos;: 93.49373626709, &apos;group_id&apos;: &apos;wenzheng&apos;&#125;]&#125;&#125;&quot;&quot;&quot;def panduan(score): if score &gt; 80: #print(type(score)) ser.write(str(score).encode()) else : ser.write(b&apos;2&apos;)def led():## led RPi.GPIO.output(18, True)if __name__ == &apos;__main__&apos;: ser = serial.Serial(&apos;/dev/ttyS0&apos;,115200,timeout=1) ser.close() ser.open() print(&quot;串口已开启&quot;) camera = PiCamera() count=0 access_token=getaccess_token() while True : take_picture() img=open_pic() output = search(img,access_token) chuli(output) count=count+1 print(count) #加入自动重启命令，防止程序运行时间过长死机 if count == 2000 : os.system(&apos;sudo reboot&apos;) count = 0","categories":[],"tags":[{"name":"树莓派","slug":"树莓派","permalink":"http://yoursite.com/tags/树莓派/"}]},{"title":"2018年5月总结","slug":"2018年5月总结","date":"2018-06-01T13:50:00.000Z","updated":"2018-06-18T02:51:34.000Z","comments":true,"path":"2018/06/01/2018年5月总结/","link":"","permalink":"http://yoursite.com/2018/06/01/2018年5月总结/","excerpt":"","text":"创客秀","categories":[],"tags":[{"name":"总结","slug":"总结","permalink":"http://yoursite.com/tags/总结/"}]},{"title":"python实现qq机器人qqbot","slug":"python制作QQ机器人-QQbot","date":"2018-06-01T02:19:00.000Z","updated":"2018-06-01T02:19:18.000Z","comments":true,"path":"2018/06/01/python制作QQ机器人-QQbot/","link":"","permalink":"http://yoursite.com/2018/06/01/python制作QQ机器人-QQbot/","excerpt":"","text":"以下内容为转载一、介绍qqbot 是一个用 python 实现的、基于腾讯 SmartQQ 协议的 QQ 机器人框架，可运行在 Linux 、 Windows 和 Mac OSX 平台下。 本项目 github 地址： https://github.com/pandolia/qqbot 你可以通过扩展 qqbot 来实现： 监控、收集 QQ 消息自动消息推送聊天机器人通过 QQ 远程控制你的设备二、安装方法在 Python 2.7/3.4+ 下使用，用 pip 安装： pip install qqbot或者下载 源码 解压后 cd 到该目录并运行： “pip install .” 三、使用方法 启动 QQBot在命令行输入： qqbot ，即可启动一个 QQBot 。 启动过程中会自动弹出二维码图片，需要用手机 QQ 客户端扫码并授权登录。启动成功后，会将本次登录信息保存到本地文件中，下次启动时，可以输入： qqbot -q qq号码 ，先尝试从本地文件中恢复登录信息（不需要手动扫码），只有恢复不成功或登录信息已过期时才会需要手动扫码登录。一般来说，保存的登录信息将在 2 天之后过期。 注意： Linux 下，需要系统中有 gvfs-open 或者 shotwell 命令才能自动弹出二维码图片（一般安装有 GNOME 虚拟文件系统 gvfs 的系统中都会含这两个命令之一）。 Windows10 下，需要系统中已设置了 png 图片文件的默认打开程序才能自动弹出二维码图片。 若系统无法自动弹出二维码图片，可以手动打开图片文件进行扫码，也可以将二维码显示模式设置为 邮箱模式 、 服务器模式 或 文本模式 进行扫码，详见本文档的第七节。 操作 QQBotQQBot 启动后，在另一个控制台窗口使用 qq 命令操作 QQBot ，目前提供以下命令： 1） 帮助、停机和重启命令 qq help|stop|restart|fresh-restart 2） 联系人查询、搜索命令 qq list buddy|group|discuss [$cinfo|$clike] ( $cinfo --&gt; $qq|$name|$key=$val ) ( $clike --&gt; :like:$qq|:like:$name|$key:like:$name ) qq list group-member|discuss-member $oinfo|$olike [$cinfo|$clike] ( $oinfo --&gt; $oqq|$oname|$okey=$oval ) ( $cinfo --&gt; $qq|$name|$key=$val ) ( $olike --&gt; :like:$oqq|:like:$oname|$okey:like:$oname ) ( $clike --&gt; :like:$qq|:like:$name|$key:like:$name ) 3） 联系人更新命令 qq update buddy|group|discuss qq update group-member|discuss-member $ginfo 4） 消息发送命令 qq send buddy|group|discuss $rinfo $message 5） 群管理命令： 设置/取消管理员 、 设置/删除群名片 、 群成员禁言 以及 踢除群成员 qq group-set-admin $ginfo $minfo1,$minfo2,... qq group-unset-admin $ginfo $minfo1,$minfo2,... qq group-set-card $ginfo $minfo1,$minfo2,... card qq group-unset-card $ginfo $minfo1,$minfo2,... qq group-shut $ginfo $minfo1,$minfo2,... [t] qq group-kick $ginfo $minfo1,$minfo2,... 6） 加载/卸载/显示插件 qq plug/unplug myplugin qq plugins list 命令提供强大的联系人查询和搜索功能，用法示例如下： 列出所有好友qq list buddy 列出 QQ 为 123456 的群qq list group 123456 列出备注名为 jack 的好友qq list buddy mark=jack 列出 群“456班” 的所有成员qq list group-member 456班 列出 群“456班” 中名片为 “mike” 的成员qq list group-member 456班 card=mike 列出 讨论组“XX小组” 中名为 jack 的好友qq list discuss-member XX小组 jack其中第三、四个参数如果是 key=val 的格式，则应为 name=xx|nick=xx|mark=xx|card=xx|qq=xx 的格式，如果不是 key=val 的格式，则按以下原则进行处理：若是一串数字，则按 QQ 号进行查询，否则，按名称进行查询。 如果存在重名现象，会列出所有重名的联系人。如： qq list group 机器人测试将列出所有名为 “机器人测试” 的群。 如果在 list 命令的第三、四个参数中加入 “:like:” ，则会按部分匹配的模式进行搜索，用法示例如下： 列出名称中含有 “李” 的好友qq list buddy :like:李 列出 QQ 中含有 “234” 的群qq list group :like:234 列出备注名中含有 jack 的好友qq list buddy mark:like:jack 列出 群“456班” 的中名称中含有 “李” 的成员qq list group-member 456班 :like:李 列出 群“456班” 中名片中含有 “mike” 的成员qq list group-member 456班 card:like:mike 列出的 讨论组“xx小组” 中名为 jack 的好友qq list discuss-member :like:小组 jack从 v2.2.5 版开始， list 命令采用表格的形式输出联系人列表，其输出样式示例如下： 为保证表格在终端中的显示效果，建议将终端的输出字体设置为 consolas 、且每行可打印的最大字符数大于 120 。另外需要注意：为保证表格的显示效果，当联系人的名称、名片等属性的长度太长或含有特殊字符时，将对这些属性进行截断或过滤后再输出至终端。 update 命令更新指定的联系人列表，其参数含义和 list 命令相同，如： 更新好友列表qq update buddy 更新群列表qq update group 更新 群“456班” 的成员列表qq update group-member 456班send 命令中第三个参数和 list 命令中的第三个参数格式一致。要注意，如果有重名现象，会给所有重名的联系人发信息。 另外要注意，第二个参数只能是 buddy/group/discuss ，不能是 group-member/discuss-member 。示例： 给 好友“jack” 发消息 “你好”qq send buddy jack 你好 给 群“198班” 发消息 “大家好”qq send group 198班 大家好 给 QQ 为 12345 的好友发消息qq send buddy 12345 xxx 给讨论组发消息qq send discuss MyDiscuss hello可以在消息内容中嵌入“/可爱”等表情关键词来向对方发送表情，详见 facemap.py。还可以在消息内容中使用 \\n,\\t 这两个转义字符（如： send buddy jack 第一行\\n第二行）。 群管理命令中的 $ginfo 和 $minfo 和 list 命令中的第三、四个参数格式一致。例如： 禁止 群“456班” 中的 jack,mike,jim 发言（ 2 分钟）qq group-shut 456班 jack,mike,jm 120以上所有命令都提供对应的 HTTP API 接口，供 web 前端开发者调用，接口的 url 地址为 http://127.0.0.1:8188/{command} ，只需要将 qq 后面的命令各参数用 “/“ 分隔开替换 url 中的 command 就可以了，如: http://127.0.0.1:8188/send/buddy/jack/hello ，其他示例详见 urltestbot.md 。注意：如果命令中含有中文或特殊字符，需要先进行 url 编码（ utf8 ），例如，调用 http://127.0.0.1:8188/send/buddy/jack/nihao%20%E4%BD%A0%E5%A5%BD%20wohao 将发送消息 ”nihao 你好 wohao“ 。（提示：在 JavaScript 中，可以使用 encodeURIComponent 函数进行编码）。 另外， QQBot 启动后，用本 QQ 号在其他客户端（如：手机 QQ ）上向某个 群/讨论组 发消息 “–version” ，则 QQBot 会自动在该 群/讨论组 回复： “QQBot-v2.x.x” 。 四、实现你自己的 QQ 机器人实现自己的 QQ 机器人非常简单，只需要定义一个自己的消息响应函数并按插件加载。示例代码： -- coding: utf-8 --def onQQMessage(bot, contact, member, content): if content == ‘-hello’: bot.SendTo(contact, ‘你好，我是QQ机器人’) elif content == ‘-stop’: bot.SendTo(contact, ‘QQ机器人已关闭’) bot.Stop()注意，上面注册的响应函数的函数名必须为 “onQQMessage” ，函数参数也必须和上面的一致。 将以上代码另存为 sample.py （注意保存为 utf8 编码的文件）。放到 ~/.qqbot-tmp/plugins/ 目录下（ ~ 代表用户主目录， win7 下为 C:\\Users\\xxx ），或系统中可以 import 到的目录下（如 python 的安装目录下的 Lib/site-packages 目录）。 之后，保持前面的 qqbot 进程运行，在另一个控制台输入 qq plug sample ，则可将此文件中的 onQQMessage 函数注册到 QQBot 的相应事件上去。此时，用另外一个 QQ 向本 QQ 发送消息 “-hello”，则会自动回复 “你好，我是 QQ 机器人”，发送消息 “-stop” 则会关闭 QQ 机器人。 在控制台输入 qq unplug sample 可以卸载此插件及相应的回调函数。可以同时加载多个插件，此时各插件中的相应函数会依次被调用（但调用顺序和加载次序无关）。 QQBot 开始运行后，每收到一条 QQ 消息，会将消息来源、消息内容以及一个 QQBot 对象传递给已注册的消息响应函数。其中： bot : QQBot 对象，提供 List/SendTo/Stop/Restart 等接口，详见本文档第五节contact : QContact 对象，消息的发送者，具有 ctype/qq/uin/nick/mark/card/name 等属性member : QContact 对象，仅当本消息为 群消息或讨论组消息 时有效，代表实际发消息的成员content : str 对象，消息内容contact 代表消息发送者，其 ctype 属性可以为 ‘buddy’/‘group’/‘discuss’ ，代表 好友/群/讨论组 对象，表示本消息是 好友消息/群消息/讨论组消息 。 member 仅当本消息为 群消息或讨论组消息 时有效，代表实际发消息的成员，它的 ctype 属性可以为 ‘group-member’/‘discuss-member’ ，代表 群成员/讨论组成员 对象。当本消息为 好友消息 时， member 等于 None 。 contact 和 member 都是 QContact 对象，不同类型的 QContact 对象所具有的属性含义见： qcontact-attr 。注意所有 QContact 对象都是 只读对象 ，只能读取它的属性，不能设置它的属性，也不能向它添加额外的属性。 可以调用 QQBot 对象的 SendTo 接口向 QContact 对象发送消息，但要注意：只可以向 好友/群/讨论组 发消息， 不可以向 群成员/讨论组成员 发送消息 。也就是说，只可以调用 bot.SendTo(contact, ‘xxx’) ， 不可以调用 bot.SendTo(member, ‘xxx’) 。 五、 QQBot 对象的公开接口和属性QQBot 对象提供 List/Update/SendTo/GroupSetAdmin/GroupSetCard/GroupShut/GroupKick/Plug/Unplug/Login/Stop/Restart/FreshRestart 共计 11 个公开接口，这些接口的第一个字母都是大写的。另外，提供一个公开属性 conf 保存全局的配置信息。 一般情况下，请勿 调用/存取 此对象的其他 方法/属性 。特别的， 请勿在子线程中调用这些接口 。 以下介绍前 7 个接口和 conf 属性。 如果需要在 IDE 或 python-shell 中运行或测试以上接口，需要先关闭 qqbot 进程，并在 IDE 或 python-shell 中运行以下代码进行登录： from qqbot import _bot as botbot.Login([‘-q’, ‘1234’])（1） bot.List(tinfo, [cinfo]) –&gt; [contact0, contact1, …, ]/[]/None对应本文档第三节的 list 命令。返回联系人对象（ QContact 对象）列表或者 None 。第一个参数 tinfo 是联系人列表的代号，第二个参数是可选的（和 list 命令的第三个参数格式一致）。 参数 tinfo 用来代表某个联系人列表，该参数在联系人的查询中非常重要，请务必理解以下两种情况 ： tinfo 的含义（情况1）： tinfo 可以为 ‘buddy’/‘group’/‘discuss’ ，分别代表 好友列表/群列表/讨论组列表 。示例： 返回 好友列表： bot.List(‘buddy’) 返回名为 ‘jack’ 的好友的列表： bot.List(‘buddy’, ‘jack’) 返回 群列表： bot.List(‘group’) 返回名为 “机器人测试” 的群的列表： bot.List(‘group’, ‘机器人测试’)tinfo 的含义（情况2）： tinfo 也可以是一个 ctype 等于 ‘group’/‘discuss’ 的 QContact 对象，代表该 群/讨论组 的成员列表。如以下第二句和第三句分别返回 群“456班” 的成员列表和该群中名片为 “jack” 的成员列表： g = bot.List(‘group’, “456班”)[0] # g 是一个 Group 对象（群“456班”）bot.List(g) # 返回 群“456班” 的成员列表bot.List(g, ‘card=jack’) # 返回 群“456班” 中名片为 “jack” 的成员列表注意上面第三句不允许是 bot.List(g, card=’jack’) 的格式。 List 接口的内部执行顺序： 首先在 QQBot 的联系人数据库内查找 tinfo 所代表的联系人列表；若数据库内已有此列表，则在此列表内进行搜索，并返回一个包含 “此列表中所有和 cinfo 匹配的联系人” 的列表；若数据库内没有此列表，则向 QQ 服务器请求数据获取联系人列表，获取成功后将联系人列表保存到数据库内，然后再进行搜索并返回一个包含 “此列表中所有和 cinfo 匹配的联系人” 的列表；如果在向 QQ 服务器请求数据的过程中出错了，则打印相关的失败信息，并返回 None 。 List 接口返回值的含义： 返回一个非空列表表示 tinfo 所指定的联系人列表内所有和 cinfo 匹配的联系人；返回一个空列表表示该联系人列表内没有和 cinfo 匹配的联系人；返回 None 表示向 QQ 服务器请求联系人列表和资料失败，不知道是否有相匹配的联系人。 调用 List 接口后， 务必 先根据以上三种情况对返回值进行判断，然后再执行后续代码。 （2） bot.Update(tinfo) –&gt; True/FalseUpdate 接口的参数 tinfo 和 List 接口中的参数含义相同，调用此接口会立即向 QQ 服务器请求相应的联系人列表并更新联系人数据库，并一直阻塞至更新成功。更新最慢的是好友列表，若好友较多可能会阻塞 5 ~ 10 秒。成员列表更新的较快，即便是 2000 人的大群，更新时间仅 1 ~ 2 秒。 若更新成功，返回 True ，否则，返回 False 。 示例： 更新 好友列表 ： bot.Update(‘buddy’) 更新 群列表 ： bot.Update(‘group’) 更新 某个群的成员列表 ： gl = bot.List(‘group’, “456班”)if gl: g = gl[0] bot.Update(g)（3） bot.SendTo(contact, content, resendOn1202=True) –&gt; ‘向 xx 发消息成功’/‘错误：…’向联系人发送消息。第一个参数为 QContact 对象，第二个参数为消息内容。再次提醒： 只可以向 好友/群/讨论组 发消息， 不允许向 群成员/讨论组成员 发消息 。 可以在消息内容中嵌入“/微笑”等表情关键词来向对方发送表情，详见 facemap.py 。 若发送成功，返回字符串（’向 xx 发消息成功’）。否则，返回含错误原因的字符串（’错误：…’）。 发消息时可能会重复发消息，这是因为 QQ 服务器返回代码 1202 的原因。v2.1.17版已针对此问题在 bot.SendTo 接口中增加了一个参数： resendOn1202 ，若此参数为 True （默认值），则发消息时如果 QQ 服务器返回代码 1202 （表明发消息可能失败），还会继续发送 3 次，直至返回代码 0 ， 若此参数为 False ，则不会尝试重发。 设为 True 在绝大部分情况下能保证消息一定能发出去，但缺点是有时一条消息会重复发送。设为 False 则相反，消息不会重复发送，但有时消息发送不出去。 总之因为这个 1202 代码的不确定性，没有完美的解决办法。请根据各自的实际情况选择 resendOn1202 的值。 第一个参数 contact 必须是通过 bot.List 返回的 QContact 对象、或回调函数 onQQMessage 传递进来的第一个参数。示例： 向 QQ 为 12345 的好友发消息 bl = bot.List(‘buddy’, ‘12345’)if bl: b = bl[0] bot.SendTo(b, ‘hello’)（4） bot.GroupXXX(group, membs[, arg]) –&gt; [‘成功：…’, ‘成功：…’, ‘错误：…’]对应第三节的群管理命令，共四个接口： 设置/取消管理员： bot.GroupSetAdmin(group, membs, admin=True)设置/取消群成员名片： bot.GroupSetCard(group, membs, card)禁止群成员发言： bot.GroupShut(group, membs, t=60)踢除群成员： bot.GroupKick(group, membs)其中第一个参数 group 为 群对象（ ctype 等于 ‘group’ 的 QContact 对象），第二个参数 membs 为被操作的成员列表。返回值为 membs 中各成员的操作信息。示例代码： 禁止 群“456班” 中名称为 jack 的成员发言（120秒）gl = bot.List(‘group’, ‘456班’)if gl: group = gl[0] membs = bot.List(group, ‘jack’) if membs: bot.GroupShut(group, membs, 120)注意： 1） 第二个参数 membs 是一个 list 对象（如： [memb0,memb1,…] ），而不是一个 QContact 对象； 2） 若 membs 中的某个成员是管理员，则除 SetCard 外的其他接口可能对其无效，尽管此时返回成功信息。 3） 使用这四个接口时，请自行保证登录的用户是该群的管理员，且 membs 中的各成员均属于该群。 （5） bot.confbot.conf 中保存全局的配置信息，各项配置详见本文档第七节。如 bot.conf.termServerPort 保存 QQBot 命令行服务器的端口号， bot.conf.qq 保存本次登录的 QQ 号码。 注意： bot.conf 中保存的配置信息是只读的，请勿修改这些配置信息。 六、 注册回调函数、被他人 @ 的通知、判断是否是自己发的消息、定制定时任务注册回调函数除了上面提到的 onQQMessage 响应函数，还可以注册 onInit/onQrcode/onStartupComplete/onInterval/onUpdate/onPlug/onUnplug/onExit 共计九种事件的回调函数，所有事件的回调函数参数格式、含义及示例详见 sampleslots.py 。 程序的运行流程以及各回调函数的调用时机如下： 再次提醒：注册的回调函数的函数名以及函数参数（数量和名称）都不得更改 。 被群内其他成员 @ 的通知QQBot 收到群消息时，会先根据消息内容判断是否有人 @ 自己。如果是，则在消息内容的开头加一个 ‘[@ME] ‘ 的标记，再传递给 onQQMessage 函数；否则，将消息内容中的所有 ‘@ME’ 替换成 ‘@Me’ 再传给 onQQMessage 。因此，在 onQQMessage 函数内，只需要判断 content 内是否含有 ‘@ME’ 就知道自己是否被消息发送者 @ 了。例如： def onQQMessage(bot, contact, member, content): if ‘@ME’ in content: bot.SendTo(contact, member.name+’，艾特我干嘛呢？’)请注意，若群内有另一个成员的名字和自己的名字的开头部分相同（如：自己的名字是 ab ，另一个成员的名字是 abc ），那么当有人 @abc 时，也会误报成 @ME ，在这种情况下，需要修改自己的群名片，以免误报。 判断是否是自己发的消息当本 QQ 在群内或讨论组内发言时， QQBot 也会收到一条同样的消息，此时 onQQMessage 中的 contact 参数就是该 群/讨论组 对象， member 参数就是自己在该 群/讨论组 中的成员对象，此时 member.uin 就是本次登录的 QQ 号码，因此，在 onQQMessage 中，只要判断 member 的 uin属性 是否是本次登录的 QQ 号码就可以知道是否是自己的发的消息了，例如： from qqbot.utf8logger import INFO def onQQMessage(bot, contact, member, content): if getattr(member, ‘uin’, None) == bot.conf.qq: # 注意：不要使用 member.uin INFO(‘你在 %s 内发言’, contact)定制定时任务从 2.1.13 起， qqbot 提供一个功能强大的函数装饰器 – qqbotsched 来定制定时任务，示例代码： from qqbot import qqbotsched @qqbotsched(hour=’11,17’, minute=’55’)def mytask(bot): gl = bot.List(‘group’, ‘456班’) if gl is not None: for group in gl: bot.SendTo(group, ‘同志们：开饭啦啦啦啦啦啦！！！’)以上代码以插件形式加载后，每到 11:55 和 17:55 ，都会自动向 群“456班” 发送消息：“同志们：开饭啦啦啦啦啦啦！！！” 。 qqbotsched 装饰器接受 year, month, day, week, day_of_week, hour, minute, second, start_date, end_date, timezone 共计 11 个关键字参数，每个参数表示任务的定制时间的分量所应匹配的值。例如： hour=’11,17’ 表示应在 11:xx 或 17:xx 执行任务， minute=’55’ 表示应在 xx:55 执行任务， minute=’0-55/5’ 表示应在 xx:00, xx:05, xx:10, …, xx:55 执行任务， day_of_week=’mon-fri’ （或 ‘0-4’ ） 表示应在 星期一 ~ 星期五 执行任务。 qqbotsched 是对 Python 的定时任务框架 apscheduler 的简单封装，其各项参数应采用 Unix 系统中的 crontab 格式输入。有关 crontab 以及 Python 的定时任务框架 apscheduler 的内容可参见以下参考资料： https://code.tutsplus.com/tutorials/scheduling-tasks-with-cron-jobs--net-8800/http://apscheduler.readthedocs.io/en/latest/userguide.htmlhttps://lz5z.com/Python定时任务的实现方式/http://debugo.com/apscheduler/crontab 各项参数格式说明详见： http://apscheduler.readthedocs.io/en/latest/modules/triggers/cron.html注册回调函数和定制定时任务的注意事项注册回调函数和定制定时任务是对 QQBot 进行扩展的唯一方式，在编写这些函数时，请注意以下事项： 回调函数的函数名、参数名、参数数量、参数顺序都不得更改定时任务的函数名可以自己定义，但参数有且只有一个，参数名必须为 bot ，为一个 QQBot 对象。所有回调函数和定时任务都将在主线程中被依次调用，因此不必担心全局变量的线程安全问题。回调函数和定时任务的运行时间应尽量短，尽量不要再这些函数中进行阻塞式的操作，否则会阻塞整个程序的运行。一般来说，每个函数的运行时间在 5 秒以内是可以接受的。绝对不要 在回调函数、定时任务或 qqbot 主线程的内部调用 os.system 执行 本 QQ 号对应的 qq 命令 （ 如 os.system(‘qq send buddy jack hello’) ）或请求 本 QQ 号对应的 HTTP-API 接口 ，否则整个程序会形成死锁（因为 os.system 要等 qq 命令执行完成后才返回、而 qq 命令要等 os.system 返回后才会被执行）。请直接使用 bot 的 SendTo/List/GroupXXX 等接口。七、二维码管理器、QQBot 配置、命令行参数以及工作目录二维码的显示模式WebQQ 登录时需要用手机 QQ 扫描二维码图片，在 QQBot 中，二维码图片可以通过以下四种模式显示： GUI模式： 在 GUI 界面中自动弹出二维码图片邮箱模式： 将二维码图片发送到指定的邮箱服务器模式： 在一个 HTTP 服务器中显示二维码图片文本模式： 在 Term 中以文本形式展示二维码(需要自行安装 pillow 和 wcwidth 库)GUI 模式是默认的模式，只适用于个人电脑。邮箱模式可以适用于个人电脑和远程服务器。服务器模式一般只在有公网 ip 的系统中使用。如果使用 QQ 邮箱来接收二维码，则发送二维码图片之后，手机 QQ 客户端会立即收到通知，在手机 QQ 客户端上打开邮件，再长按二维码就可以扫描了。文本模式方便在开发过程或者服务器部署时使用，为开发者提供快捷方式登陆 QQ 。 注意：当开启了 邮箱模式/服务器模式/文本模式 时， GUI 模式是关闭的，登陆时不会自动弹出二维码图片。 每次登录时会创建一个二维码管理器 （ QrcodeManager 对象） ，二维码管理器会根据配置文件及命令行参数来选择二维码图片的显示方式。 配置文件的使用方法配置文件为 ~/.qqbot-tmp/v2.x.conf ，第一次运行 QQBot 后就会自动创建这个配置文件，其中内容如下： { # QQBot 的配置文件 # 使用 qqbot -u somebody 启动程序时，依次加载： # 根配置 -&gt; 默认配置 -&gt; 用户 somebody 的配置 -&gt; 命令行参数配置 # 使用 qqbot 启动程序时，依次加载： # 根配置 -&gt; 默认配置 -&gt; 命令行参数配置 # 用户 somebody 的配置 &quot;somebody&quot; : { # QQBot-term （HTTP-API） 服务器端口号（该服务器监听 IP 为 127.0.0.1 ） # 设置为 0 则不会开启本服务器（此时 qq 命令和 HTTP-API 接口都无法使用）。 &quot;termServerPort&quot; : 8188, # 二维码 http 服务器 ip，请设置为公网 ip 或空字符串 &quot;httpServerIP&quot; : &quot;&quot;, # 二维码 http 服务器端口号 &quot;httpServerPort&quot; : 8189, # 自动登录的 QQ 号 &quot;qq&quot; : &quot;3497303033&quot;, # 接收二维码图片的邮箱账号 &quot;mailAccount&quot; : &quot;3497303033@qq.com&quot;, # 该邮箱的 IMAP/SMTP 服务授权码 &quot;mailAuthCode&quot; : &quot;feregfgftrasdsew&quot;, # 是否以文本模式显示二维码 &quot;cmdQrcode&quot; : False, # 显示/关闭调试信息 &quot;debug&quot; : False, # QQBot 掉线后自动重启 &quot;restartOnOffline&quot; : False, # 在后台运行 qqbot ( daemon 模式) &quot;daemon&quot;: False, # 完成全部联系人列表获取之后才启动 QQBot &quot;startAfterFetch&quot; : False, # 插件目录 &quot;pluginPath&quot; : &quot;.&quot;, # 启动时需加载的插件 &quot;plugins&quot; : [], # 插件的配置（由用户自定义） &quot;pluginsConf&quot; : {}, }, # 可以在 默认配置 中配置所有用户都通用的设置 &quot;默认配置&quot; : { &quot;qq&quot; : &quot;&quot;, &quot;pluginPath&quot; : &quot;&quot;, &quot;plugins&quot; : [ &apos;qqbot.plugins.sampleslots&apos;, &apos;qqbot.plugins.schedrestart&apos;, ], &quot;pluginsConf&quot; : { &apos;qqbot.plugins.schedrestart&apos;: &apos;8:00&apos;, } }, # # 注意：根配置是固定的，用户无法修改（在本文件中修改根配置不会生效） # &quot;根配置&quot; : { # &quot;termServerPort&quot; : 8188, # &quot;httpServerIP&quot; : &quot;&quot;, # &quot;httpServerPort&quot; : 8189, # &quot;qq&quot; : &quot;&quot;, # &quot;mailAccount&quot; : &quot;&quot;, # &quot;mailAuthCode&quot; : &quot;&quot;, # &quot;cmdQrcode&quot; : False, # &quot;debug&quot; : False, # &quot;restartOnOffline&quot; : False, # &quot;daemon&quot; : False, # &quot;startAfterFetch&quot; : False, # &quot;pluginPath&quot; : &quot;&quot;, # &quot;plugins&quot; : [], # &quot;pluginsConf&quot; : {} # }, }可以在配置文件中添加自己的用户配置（即在该文件的字典中新增一个 item ，此 item 的 key 就代表一个用户），例如，该文件中已有的 somebody 项目就代表名为 somebody 的用户，运行 QQBot 时，输入 qqbot -u somebody ，则会加载 somebody 项目下的各项配置。 下面介绍配置文件中各项配置的功能，以下内容均假定已修改了 somebody 下的配置，且以 qqbot -u somebody 的方式运行。 邮箱模式的配置（ mailAccount 和 mailAuthCode ）如果需要使用邮箱模式显示二维码，可以将 mailAccount 和 mailAuthCode 项中分别设置为邮箱帐号和授权码，运行后，二维码管理器会将二维码图片发送至该邮箱。 注意：授权码不是邮箱的登录密码，而是邮箱服务商提供的开通 IMAP/SMTP 服务的授权码（提醒：不是 POP3/SMTP 服务）， QQ/网易 邮箱可以在网页版的邮箱设置里面开通此项服务，并得到授权码。如果只定义了 mailAccount 而没定义 mailAuthCode ，则程序运行的开始时会要求手工输入此授权码。 邮箱模式已在 QQ 、 网易 和 Google 邮箱中测试过。 服务器模式的配置（ httpServerIP 和 httpServerPort ）如果需要使用服务器模式，可以配置 httpServerIP 和 httpServerPort 项，一般来说应该设置为公网 ip 。服务器模式开启后，可以通过 http://{httpServerIP}:{httpServerPort}/{any} 来访问二维码图片。其中 {any} 可以是任何非空的数字或字母串。 当邮箱模式和服务器模式同时开启时，发邮件时不会发送真正的图片，只会将图片地址发到邮箱中去，而且只发送一次，二维码过期时刷新一下邮件就可以了。如果只开启邮箱模式，则发邮件时会发送真正的图片，当二维码过期时，需要将邮件设置为已读（用手机 QQ 点开邮件后该邮件就是已读了），之后才会发送最新的二维码图片。 文本模式显示二维码（cmdQrcode）若 cmdQrcode 项设置为 True ，则会在 term 中以文本模式显示二维码。注意：要使用文本模式，需要自行安装 pillow 和 wcwidth 库，可使用 pip 安装。 自动登录的 QQ 号码（ qq ）配置文件中每个用户都有 qq 这一项，若此项已设置为某 QQ 号码，则 QQBot 在启动时会先使用此 QQ 号上次登录保存的登录信息来自动登录。 掉线后自动重启（ restartOnOffline ）如果配置文件中将 restartOnOffline 项设置为 True ，则当 QQBot 掉线或出错终止时，会自动重新启动 QQBot 。 在后台运行 qqbot （ daemon ）此选项仅在 UNIX 类系统中有效，将配置中的 daemon 选项设置为 True 则会以 daemon 模式运行程序。此时，标准输出和标准错误会重定向到 daemon-$qq.log 文件（其中 $qq 是配置中 qq 选项的值）。 联系人列表获取完成后再启动（ startAfterFetch ）一般情况下，扫码登录完成就立即启动 QQBot，只有在需要的时候才会去获取联系人列表并更新联系人数据库。如果将配置文件中的 startAfterFetch 设置为 True ，则 QQBot 会等待所有联系人列表获取完成后才启动 ，注意，如果联系人较多，会耗费较长的时间。 QQBot-term 服务器端口号（ termServerPort ）QQBot 启动后，会开启一个 QQBot-term 服务器监听用户通过 qq 命令行工具发过来的操作命令以及通过 HTTP API 接口发过来的操作命令，此服务器的监听 IP 永远为 127.0.0.1 ，监听端口号默认为 8188 ，可以通过修改 termServerPort 的值来修改此端口号。 如果配置的 QQBot-term 服务器端口号不是默认的 8188 ，那么在运行 qq 命令时，需要在第一个参数中指定端口号，如： $ qq 8100 send buddy jack hello$ qq 8100 list group-member chatbot同样，HTTP API 接口的端口号也需要改变，如： http://127.0.0.1:8100/send/buddy/jack/hello 。 如果不需要使用 qq 命令和 HTTP-API 接口，可以将此端口号设置为 0 ，此时 QQBot-term 服务器不会开启。 如果需要在同一台机器上登录多个 QQ 号码，可以直接在不同的终端中开启多个 qqbot 进程进行登录，但是，每个 qqbot 进程必须设置专有的 termServerPort 和 httpServerPort （或者全部设置为 0 或 空值 ），否则会造成端口号冲突。 调试模式（ debug ）若 debug 项设置为 True ，则运行过程中会打印调试信息。 插件的配置（ pluginPath 和 plugins ）一般情况下，插件需要存放在系统的 import 目录下或 ~/.qqbot-tmp/plugins 目录下，可以在 pluginPath 选项中配置其他的存放目录。另外，在 plugins 选项中可以指定 QQBot 启动时需要加载的插件。 命令行参数及配置的优先级配置文件中的所有选项都有对应的命令行参数，在命令行参数中输入的选项优先级比配置文件高。输入 qqbot -h 可查看所有命令行参数格式。 程序一共有四个级别的配置，其优先级如下： 使用 qqbot -u somebody 启动程序时，依次加载： 根配置 -&gt; 默认配置 -&gt; 用户 somebody 的配置 -&gt; 命令行参数配置 使用 qqbot 启动程序时，依次加载： 根配置 -&gt; 默认配置 -&gt; 命令行参数配置其中：根配置 是固定的，用户无法修改； 默认配置 和 用户配置 可由用户在 v2.x.conf 文件中进行修改；最后，还可以在 命令行参数 中输入配置。 工作目录qqbot 运行时，会在 工作目录 下 搜索/创建 以下 文件/目录 ： 配置文件： v2.x.conf插件目录： plugins/登录文件： v2.x-pyx-xxxx.pickle联系人数据库文件： 2017-05-06-20-03-12-xxxx-contact.db临时二维码图片： xxxx.png保存QQ的文件： qq(pid9816)以 daemon 模式运行时的 log 文件： daemon-xxx.log默认的工作目录为 ~/.qqbot-tmp/ ，可以在启动 qqbot 时通过命令行参数 -b|–bench 指定其他工作目录，例如： qqbot -b bench 。 八、 插件插件的存放位置插件实际上是一个 python 模块，因此可以是一个 python 文件，也可以是一个 python package。 qqbot 会根据插件名在以下目录中搜索插件： 配置中的 pluginPath 选项（命令行参数 -pp|–pluginPath ）指定的目录工作目录下的 plugins 目录python 的导入目录插件的加载/卸载hot-plug 方式 可以在 qqbot 的运行过程中动态的加载/卸载插件，有以下三种方法： 利用 qq 命令行工具： qq plug pluginname 或 qq unplug pluginname利用 http-api 接口： http://127.0.0.1:8188/plug/pluginname 或 http://127.0.0.1:8188/unplug/pluginname利用 bot 对象的接口： bot.Plug(‘pluginname’) 或 bot.Unplug(‘pluginname’)前面两种方法是供 qqbot 进程的外部进程调用的，第三种方法是在 qqbot 进程内部使用的。请勿在 qqbot 进程的内部使用前面两种方法。 注意：采用 hot-plug 方式加载的插件在 qqbot 重启后会丢失。 auto-plug-at-start 方式 也可以在 qqbot 的启动时自动加载插件，在配置中的 plugins 选项（命令行参数 -pl|–plugins ）中指定需要加载的插件名就可以了。这些插件将在启动时、登录之前被加载。 另外，如果系统中（或插件目录中）存在名为 qqbotdefault 的 package ，那么该 package 下面的所有子模块都会被当成插件在启动时自动加载（注意：qqbotdefault 本身不会作为插件加载）。 插件内的 onPlug 和 onUnplug 回调函数插件被加载时，会执行 reload(pluginName) ，因此插件内的所有代码都会被执行一次当采用 hot-plug 的方式加载时，插件内的 onPlug 函数会紧接在 reload 成功后被执行当采用 auto-plug-at-start 方式加载时，插件在启动时、登录之前被加载，但插件内的 onPlug 函数会延迟到登录成功后才被执行插件被卸载时，插件内的 onUnplug 被执行插件的编写编写插件主要就是编写回调函数或定时任务函数，详见 第四~六节 。 插件列表名称 github作者 功能说明 是否默认加载qqbot.plugins.sampleslots pandolia 回调函数示例 是qqbot.plugins.schedrestart pandolia 定时重启 是qqbot.plugins.miniirc pandolia IRC服务器 否adblock feisuweb 群广告拦截 否chatlog feisuweb 聊天内容记录 否如果您有好用的插件分享，欢迎发邮件给我。 九、 命令行模式下使用 IRC 聊天linux 系统下，由于无法使用 QQ 客户端，可以使用插件 qqbot.plugins.miniirc 来实现用 IRC 聊天的功能。加载方式： qq plug qqbot.plugins.miniirc ，或启动时加载： qqbot -pl qqbot.plugins.miniirc ，或者在配置文件中的 plugins 选项中加入 ‘qqbot.plugins.miniirc’ 。 插件加载后将在 6667 端口开启一个微型的 IRC 服务器，用户可以使用 IRC 客户端（如 weechat, irssi 等）连接此服务器来实现命令行模式下的聊天。以下以 weechat 为例介绍使用方法： 启动 weechat ： weechat 连接本服务器： /connect localhost 进入 群聊天 会话： /join group-name 进入 讨论组聊天 会话： /join !discuss-name 进入 好友聊天 会话： /query buddy-name 进入 聊天会话 后，直接敲入文本并回车就可以向对方发送消息了。所有接收到的 QQ 消息也会被转发给相应的 聊天会话 。 在聊天会话之间切换： ctrl+P 或 ctrl+N 显示所有 群和讨论组 的名称： /list以上几乎就是此微型 IRC 服务器所提供的所有功能了，但已经足够用来和 QQ 好友/群/讨论组 聊天了。 十、 smartqq 协议支持及限制本项目已实现绝大部分 smartqq 协议支持的功能，如下：消息收/发联系人（包括 好友/群/讨论组/群成员/讨论组成员）资料获取和查询（包括 QQ号/昵称/名称/备注名/群成员名片）联系人资料根据需要动态更新被群内其他成员 @ 的通知群管理功能： 设置/取消管理员 、 设置/删除群名片 、 群成员禁言 以及 踢除群成员发送、接收表情（详见 facemap.py）其他功能：调用系统默认图片浏览器显示登录二维码、将登录二维码发送至邮箱、开启一个 http 服务器用来显示登录二维码、在命令行窗口使用文本模式显示二维码用 qq 命令行工具发消息、查询|更新联系人、群管理提供 HTTP-API 接口发消息、查询|更新联系人、群管理提供 miniirc 插件，可以在命令行模式下使用 IRC 客户端聊天掉线后自动重启功能（有时需要手工扫码）定时执行任务（通过 qqbotsched 实现）因 smartqq 协议的限制，以下问题没有好的解决办法：无法长时间保持在线状态，每次登录成功后的 cookie 会每在 1 ~ 2 天后失效，将被腾讯服务器强制下线，此时 必须 手工扫码重新登录。可以打开邮箱模式和自动重启模式，并配合 qqbot.plugins.schedrestart 插件使用，每天在固定的时间扫码登录一次，基本上可以稳定的保持在线状态。无法发送图片、文件、音频、 xml 卡片消息无法获取到自己通过其他客户端（手机 QQ 、PC-QQ）发送的 好友 消息（提示：自己发送的 群/讨论组 消息可以获取到）当 好友/群/群成员 存在同名现象或名称中含特殊字符时，无法绑定其实际 QQ无法在群内 @ 其他成员，即便用本程序在群里发送了 “@jack xxx” 这样的消息， jack 也只能收到这个纯文本，收不到“有人@我”的提醒。无法向 群/讨论组 内的其他非好友成员发消息，也无法收到非好友成员发过来的临时会话消息在非常少的情况下，发消息时会重复发送多次，也可能对方已收到消息但返回发送失败的结果十一、其他常见问题更新日志十二、参考资料QQBot 参考了以下开源项目： ScienJus/qqbot (ruby)floatinghotpot/qqbot (node.js)sjdy521/Mojo-Webqq (perl)在此感谢以上三位作者的无私分享，特别是感谢 ScienJus 对 SmartQQ 协议所做出的深入细致的分析。 十三、反馈有任何问题或建议可以发邮件给我 pandolia@yeah.net ，或者在 github 上提 issue ，也可以加 QQ 群： 577126408 。但还是希望您在提问之前通读一下本文档，很有可能您想要的答案已经在文档中了。 作者：pandolia链接：https://www.jianshu.com/p/21feace90e6c來源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"树莓派+百度api实现人脸识别","slug":"树莓派+百度api实现人脸识别","date":"2018-05-31T12:06:00.000Z","updated":"2018-05-31T13:15:56.000Z","comments":true,"path":"2018/05/31/树莓派+百度api实现人脸识别/","link":"","permalink":"http://yoursite.com/2018/05/31/树莓派+百度api实现人脸识别/","excerpt":"树莓派对接百度api 我以前玩安卓的时候一直用的讯飞的平台和api，对于百度的api很陌生，也很少用，今年百度开发平台提出了“所有功能免费”的口号，确实，其他平台的开放都是局限的。有些需要开会员，基础的功能能免费是最好的了。","text":"树莓派对接百度api 我以前玩安卓的时候一直用的讯飞的平台和api，对于百度的api很陌生，也很少用，今年百度开发平台提出了“所有功能免费”的口号，确实，其他平台的开放都是局限的。有些需要开会员，基础的功能能免费是最好的了。 之前，我用python做过face++的人脸识别，效果还是不错的，后来也在学校进行了展览，face++的平台可是支付宝用的呀，所以也是很强大的。后来买了树莓派，一直想用opencv自己做，可是opencv装了很久，貌似一直出问题，迟迟不能解决，非常吃力。今天遇到了一个教程是做的百度api，就想跟着做—–谁曾想，总是不易的，总出问题！！https://github.com/az666/pizerow_facelock/blob/master/face.py这位大神的资料是百度API2.0的教程，可是我登录百度开发者平台发现现在已经是api3.0了。只能自己照着官方的文档，一点一点的调，最终成功，效果还可以，和笔记本上的python同时实现了“人脸搜索”（api2.0叫做人脸查找） 百度文档中心后台数据： 电脑端的输出结果为： 12D:\\python_64_projects\\venv\\Scripts\\python.exe D:/python_64_projects/pizreow.py&#123;&apos;error_code&apos;: 0, &apos;error_msg&apos;: &apos;SUCCESS&apos;, &apos;log_id&apos;: 3049016445, &apos;timestamp&apos;: 1527771832, &apos;cached&apos;: 0, &apos;result&apos;: &#123;&apos;face_token&apos;: &apos;08c78a3239ad1d06548ec031fbb7f320&apos;, &apos;user_list&apos;: [&#123;&apos;group_id&apos;: &apos;wenzheng&apos;, &apos;user_id&apos;: &apos;wenzheng&apos;, &apos;user_info&apos;: &apos;pengwenzheng&apos;, &apos;score&apos;: 98.010856628418&#125;]&#125;&#125; 可见：相似度为：’user_info’: ‘pengwenzheng’, ‘score’: 98.010856628418注：python 3.x中urllib库和urilib2库合并成了urllib库。。其中urllib2.urlopen()变成了urllib.request.urlopen()…….urllib2.Request()变成了urllib.request.Request() 树莓派代码 123456789101112131415def search (): &apos;&apos;&apos; 人脸搜索 &apos;&apos;&apos; f = open(&quot;E:/opencv_pictures/face++/image/my_face.jpg&quot;, &apos;rb&apos;) img = base64.b64encode(f.read()) request_url = &quot;https://aip.baidubce.com/rest/2.0/face/v3/search&quot; params = &#123;&quot;image&quot;:img,&quot;image_type&quot;:&quot;BASE64&quot;,&quot;group_id_list&quot;:&quot;wenzheng&quot;,&quot;quality_control&quot;:&quot;LOW&quot;,&quot;liveness_control&quot;:&quot;NORMAL&quot;&#125; access_token = &apos;24.1d38fa613271b16392ddf5bad969480b.2592000.1530352882.282335-11330742&apos; request_url = request_url + &quot;?access_token=&quot; + access_token response = requests.post(request_url, data=params) test = response.json().get(&apos;score&apos;) print(response.json()) print(test)search()","categories":[],"tags":[{"name":"树莓派","slug":"树莓派","permalink":"http://yoursite.com/tags/树莓派/"}]},{"title":"智能家居完结版","slug":"智能家居控制系统资料和教程","date":"2018-05-25T12:06:00.000Z","updated":"2018-05-31T13:17:00.000Z","comments":true,"path":"2018/05/25/智能家居控制系统资料和教程/","link":"","permalink":"http://yoursite.com/2018/05/25/智能家居控制系统资料和教程/","excerpt":"智能家居控制系统模型","text":"智能家居控制系统模型 视频演示 我的工作室 资料链接参赛PPT所有资料-压缩包","categories":[],"tags":[{"name":"智能家居","slug":"智能家居","permalink":"http://yoursite.com/tags/智能家居/"}]},{"title":"2018阶段性总结","slug":"2018阶段总结","date":"2018-05-18T13:11:00.000Z","updated":"2018-05-18T13:12:44.000Z","comments":true,"path":"2018/05/18/2018阶段总结/","link":"","permalink":"http://yoursite.com/2018/05/18/2018阶段总结/","excerpt":"现在是2018年5月9日夜，突然想写一些东西，最近很少有这种感觉的，一是因为懒，二是因为没时间，也不知道自己忙忙碌碌的到底收获了什么，总之唯独忙起来，才不会感觉到空虚，自我安慰而已。这篇博文，将记录最近一个月的点点滴滴。","text":"现在是2018年5月9日夜，突然想写一些东西，最近很少有这种感觉的，一是因为懒，二是因为没时间，也不知道自己忙忙碌碌的到底收获了什么，总之唯独忙起来，才不会感觉到空虚，自我安慰而已。这篇博文，将记录最近一个月的点点滴滴。 Google特训营 前一段参加了Google特训营，主讲python教学和安卓开发，而且使我们学校计算机学院的院长和老师的主讲，自然去的绝大多数都是计算机学院的同学，关键很多都是学弟学妹，让我深感无奈，毕竟我早已是别人眼中的老学长。。。。。 中间一段舞台投影仪缺少一根转接线的小插曲，最终我和老师去工作室拿了一根，最后和老师沟通甚欢，也导致最后我成为了这一批训练营唯一上台演讲的成员，嗯嗯，很紧张刺激。 收获颇丰，虽然老师讲的太高深， 但是就因为Google的服务和赞助（不得不说中午那顿免费的午餐真的是超级丰盛。。。）这波绝对满分。 更加坚定了我学习人工智能的信念 创客作品展 这次创客作品展，几乎展出了我大三的所有作品，包括最近参赛的作品，真的是一个总结，当从新闻里，校网，院网，看到我的照片和名字，真的很有成就感。生活本该如此，简单又知足。","categories":[],"tags":[{"name":"esp8266","slug":"esp8266","permalink":"http://yoursite.com/tags/esp8266/"}]},{"title":"微信服务器get反馈","slug":"微信服务器get反馈","date":"2018-05-12T05:06:00.000Z","updated":"2018-05-31T13:19:36.000Z","comments":true,"path":"2018/05/12/微信服务器get反馈/","link":"","permalink":"http://yoursite.com/2018/05/12/微信服务器get反馈/","excerpt":"昨天无意间发现了一个很好的教程，用于微信的简易反馈，效果还可以，很好用。用到了一个开源免费的服务器，大神总是默默无闻奉献的。Server酱具体的教程源于microPython，其实他可以用于几乎所有的平台，无论是硬件和软件都可以的。像app的反馈，bug提交，硬件的数据反馈等等，都是很不错的。","text":"昨天无意间发现了一个很好的教程，用于微信的简易反馈，效果还可以，很好用。用到了一个开源免费的服务器，大神总是默默无闻奉献的。Server酱具体的教程源于microPython，其实他可以用于几乎所有的平台，无论是硬件和软件都可以的。像app的反馈，bug提交，硬件的数据反馈等等，都是很不错的。 我按照上面的教程做了一个微信温湿度反馈效果还可以。 Python语言实现： boot.py 12345678910111213import networkimport utimepdcn = network.WLAN(network.STA_IF)pdcn.active(True)pdcn.connect(&apos;maker_space&apos;, &apos;chuangke666&apos;)utime.sleep(5)if pdcn.isconnected(): print(&quot;WiFi is connected %s.&quot;%pdcn.ifconfig()[0])else: pdcn.active(False) utime.sleep(5) print(&quot;WiFi cannot connect.&quot;) main.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344# coding=utf-8import urequestsimport dhtimport machinefrom machine import Pinimport timeclass AlarmSystem: def __init__(self): self.d = dht.DHT11(machine.Pin(5)) def dht11(self): try: self.d.measure() return &apos;Temp:&apos;+str(self.d.temperature())+&apos;Hum:&apos;+str(self.d.humidity())+&apos;%&apos; except: return &apos;0&apos; def push(self, result): title = &quot;TPYBoardv202&quot; content = &apos;text=&apos;+title+&apos;&amp;&apos;+&apos;desp=&apos;+result url=&quot;https://sc.ftqq.com/这里是注册的key.send?%s&quot; % content r = urequests.get(url) r.close()p2=Pin(2,Pin.OUT)a = AlarmSystem()def SendData(): p2.value(not p2.value()) data_= a.dht11() print(data_) if(data_!=&apos;0&apos;): print(data_) a.push(data_) else: print(&apos;GET Data Fail&apos;)if __name__ == &apos;__main__&apos;: while True: SendData() time.sleep(300)","categories":[],"tags":[{"name":"温湿度","slug":"温湿度","permalink":"http://yoursite.com/tags/温湿度/"}]},{"title":"DIY一款智能插座","slug":"DIY一款智能插座","date":"2018-05-09T13:50:00.000Z","updated":"2018-06-18T02:51:10.000Z","comments":true,"path":"2018/05/09/DIY一款智能插座/","link":"","permalink":"http://yoursite.com/2018/05/09/DIY一款智能插座/","excerpt":"基于esp8266和机智云的远程控制设备的设计 比如这个插座","text":"基于esp8266和机智云的远程控制设备的设计 比如这个插座 比如手机端的app会安卓编程的也可以自己修改一下布局文件，修改一下背景和logo什么的，这样就可以做成自己的软件喽。 再可以看下这段视频 前言 前言：（此教程针对新手，大神略过）我这个人比较懒，挣扎了很久才决定写这个教程，主要是源于闲鱼的很多朋友问教程毕竟我在闲鱼从来不卖东西，偶尔发个玩意分享分享教程，哎呀，平时时间不是太多，最近的学习状态也不是太好，还有比赛，说实话（我计算机二级还没过），最近还要考试，哎呦难得很，理论和现实还是有很大差距的，写了那么久的程序，计算机二级也算是难倒我了，主要是没有太多时间去看那些知识点，风萧萧兮易水寒，今天果断下定决心坐下来，给朋友写一个教程。 1我还想说的一些话：有些东西的制作，实践比理论要重要得多，当你拿到esp8266的时候商家或者论坛肯定会给给你一些资料，让你一步一步调AT指令，建服务器，，固然有用，但是你不能从中获得优越感，和成就感，因为你根本没有做出一个能实际远程控制的一个实物，只能慢慢的从入门到放弃，让它吃灰。 关于标题：为什么说是–远程控制智能插座不用入门直接上手 –呢？ 有对应的平台服务器可以对接这次试用机智云– 服务器自动生成C语言代码 服务器自动生成安卓SDK 机智云平台–http://www.gizwits.com/为什么不选择onenet？为什么不要选择link？和其他的IOT网站？因为其他的我都做失败了。。。。。哈哈备注：我们使用的是mcu方案，为什么不采用soc的嵌入式开发呢，不太适合新手，再说了成本也差不了多少钱，仅仅一个arduino mini板的钱， 材料准备 开始吧，教程开始：首先时软件准备–机智云账号， arduinoIDE其次是硬件准备–arduino板，经测试什么样的板子都可以，无论是arduinoR3还是arduino nano还是arduinomini都可以的，还有esp8266 ESP01为什么选择ESP01呢？——-便宜呀！！其次针对mcu方案，没必要买esp12F那样的板子，接线不方便，也没必要。 正式开始 开始注册机智云账号并生成应用并配置数据点，这方面不再详述，如果有需求，下次我再下一个文章，一步一步截图发出来。官方教程如下–http://docs.gizwits.com/zh-cn/quickstart/UseMCU.html比如我的插座（带定时功能） 当你按照上面的教程做好之后，不夸张的说，你已经完成了 三分之一了。哈哈，是不是很简单，3.烧写固件–这是一个重点！论坛的资料和教程我试了很多最终一个稳定的方案就是如图的烧写方式详细教程可以看我的博客园文档http://www.cnblogs.com/pengwenzheng/p/8053167.html烧写的固件为机智云官方的固件下载地址–https://download.gizwits.com/zh-cn/p/92/94固件烧写完成之后就要进行调试了，使用机智云官方的调试工具进行远程调试，这个时候你就可以在手机下载调试软件实现远程的调试了， 到这里呢，你已经完成 一半 了，剩下的就是到机智云的服务器开发者中心，生成mcu代码，就是机智云自动生成的arduino的ino文件，是不是很舒服的说。。。。。。流程如下：接着下载即可：下载之后就是一个压缩包，接下之后是机智云针对你的应用的库文件。解压之后打开，只有一个文件名字为–Gizwits把这个库拷贝到arduinoIDE的库文件夹里即可：不然无法变编译的，大家应该是知道的。ok到这里差不多 四分之三 了，恩恩，下面的工作就剩代码的调试和硬件的组装了，代码调试如下：比如我的文件为：D:\\1arduino2018\\Arduino\\libraries\\Gizwits\\examples就是解压下来的库文件里面的两个历程：机智云官方是自动生成两个文件的，一个是联网的文件，一个是针对你设置的数据点的应用的控制代码好了将两者融合如下：例如我的插座的代码为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165#include &lt;Gizwits.h&gt;#include &lt;Wire.h&gt;#include &lt;SoftwareSerial.h&gt;SoftwareSerial mySerial(A2,A3); // A2 -&gt; RX, A3 -&gt; TXGizwits myGizwits;#define KEY1 6#define KEY2 7#define KEY1_SHORT_PRESS 1#define KEY1_LONG_PRESS 2#define KEY2_SHORT_PRESS 4#define KEY2_LONG_PRESS 8#define NO_KEY 0#define KEY_LONG_TIMER 3int flag =0;unsigned long Last_KeyTime = 0;unsigned long gokit_time_s(void)&#123; return millis() / 1000;&#125;char gokit_key1down(void)//按键函数，不用管&#123; unsigned long keep_time = 0; if (digitalRead(KEY1) == LOW) &#123; delay(100); if (digitalRead(KEY1) == LOW) &#123; keep_time = gokit_time_s(); while (digitalRead(KEY1) == LOW) &#123; if ((gokit_time_s() - keep_time) &gt; KEY_LONG_TIMER) &#123; Last_KeyTime = gokit_time_s(); return KEY1_LONG_PRESS; &#125; &#125; //until open the key if ((gokit_time_s() - Last_KeyTime) &gt; KEY_LONG_TIMER) &#123; return KEY1_SHORT_PRESS; &#125; return 0; &#125; return 0; &#125; return 0;&#125;char gokit_key2down(void)//按键函数不用管。&#123; int unsigned long keep_time = 0; if (digitalRead(KEY2) == LOW) &#123; delay(100); if (digitalRead(KEY2) == LOW) &#123; keep_time = gokit_time_s(); while (digitalRead(KEY2) == LOW) //until open the key &#123; if ((gokit_time_s() - keep_time) &gt; KEY_LONG_TIMER) &#123; Last_KeyTime = gokit_time_s(); return KEY2_LONG_PRESS; &#125; &#125; if ((gokit_time_s() - Last_KeyTime) &gt; KEY_LONG_TIMER) &#123; return KEY2_SHORT_PRESS; &#125; return 0; &#125; return 0; &#125; return 0;&#125;char gokit_keydown(void)&#123; char ret = 0; ret |= gokit_key2down(); ret |= gokit_key1down(); return ret;&#125;void KEY_Handle(void)//这里是检测按键的函数，不用管&#123; switch (gokit_keydown()) &#123; case KEY1_SHORT_PRESS: myGizwits.setBindMode(WIFI_PRODUCTION_TEST); break; case KEY1_LONG_PRESS: myGizwits.setBindMode(WIFI_RESET_MODE); break; case KEY2_SHORT_PRESS: myGizwits.setBindMode(WIFI_SOFTAP_MODE); break; case KEY2_LONG_PRESS: myGizwits.setBindMode(WIFI_AIRLINK_MODE);//这里我自己加了一个如果开启了配网功能，蜂鸣器就响一秒。很好用哦 digitalWrite(5,HIGH); digitalWrite(8,HIGH); delay(1000); digitalWrite(8,LOW); digitalWrite(5,LOW); break; default: break; &#125;&#125;void wifiStatusHandle()//这个函数我做了修改，因为没什么用。&#123; if(myGizwits.wifiHasBeenSet(WIFI_SOFTAP)) &#123; &#125; if(myGizwits.wifiHasBeenSet(WIFI_AIRLINK)) &#123; &#125; &#125;void setup() &#123; // put your setup code here, to run once: mySerial.begin(115200); pinMode(KEY1, INPUT_PULLUP); pinMode(KEY2, INPUT_PULLUP); pinMode(5,OUTPUT);//指示灯 pinMode(8,OUTPUT);//beeWIFI_AIRLINK成功报警提示这里是配网提示 pinMode(9,OUTPUT);//接继电器 digitalWrite(5,LOW); digitalWrite(8,LOW); digitalWrite(9,HIGH); myGizwits.begin();&#125;void loop() &#123; KEY_Handle();//key handle , network configure网络配置 wifiStatusHandle();//WIFI Status Handle无线网络状态处理 unsigned long varW_back = 0;//Add Sensor Data Collection myGizwits.write(VALUE_back, varW_back); bool varR_on_off = 0; if(myGizwits.hasBeenSet(EVENT_on_off)) &#123; myGizwits.read(EVENT_on_off,&amp;varR_on_off);//Address for storing data //////////////////////////////////////////////////////////////////////控制区 if(varR_on_off==1) &#123; digitalWrite(9,LOW); &#125; else digitalWrite(9,HIGH);////////////////////////////////////////////////////////////////////////////////下面是定时的代码，暂且没有写定时的程序，先不管。 &#125; unsigned long varR_time_h = 0; if(myGizwits.hasBeenSet(EVENT_time_h)) &#123; myGizwits.read(EVENT_time_h,&amp;varR_time_h);//Address for storing data mySerial.println(F(&quot;EVENT_time_h&quot;)); mySerial.println(varR_time_h,DEC); &#125; unsigned long varR_time_m = 0; if(myGizwits.hasBeenSet(EVENT_time_m)) &#123; myGizwits.read(EVENT_time_m,&amp;varR_time_m);//Address for storing data mySerial.println(F(&quot;EVENT_time_m&quot;)); mySerial.println(varR_time_m,DEC); &#125; ////////////////////////////////////////////////////////////////////////// myGizwits.process();&#125; 大功告成，装机调试，稳定运行，哎呦累死我了，写了好久，既然能控制一个设备了，哪2个呢？8个呢？肯定不是问题喽。 1好了教程到此结束，累死了，有什么疑问欢迎下方留言，有问必答！","categories":[],"tags":[{"name":"esp8266","slug":"esp8266","permalink":"http://yoursite.com/tags/esp8266/"}]},{"title":"python 爬虫制作校园网一键登录软件","slug":"python 爬虫制作校园网一键登录软件","date":"2018-05-08T13:50:00.000Z","updated":"2018-06-18T02:50:40.000Z","comments":true,"path":"2018/05/08/python 爬虫制作校园网一键登录软件/","link":"","permalink":"http://yoursite.com/2018/05/08/python 爬虫制作校园网一键登录软件/","excerpt":"python爬虫制作校园网一键登录软件 登录页面，与成功页面","text":"python爬虫制作校园网一键登录软件 登录页面，与成功页面 总结：首先呢思路和普通的post登录原理一样，而且，我也做过手机端的，但是除此调试并没有成功，不知为何。首先post抓包，然后再模拟浏览器发送，这是很普通的操作之后就是对内容的处理了，这里也学到了很多东西，包括html网页的解析，网页源码的处理等等，正则表达式也用到了一些莫烦python莫烦老师的课程也是非常棒的，教会了我很多知识，最后我的小软件运行了几天之后出问题了，就是校园网每隔几天会换一下ip地址，这使得之前保存下来的ip就不能用了，这让我也搞了好一会儿，最终还是巧妙的查到了更换的ip实现了自动捕捉ip应该可以长期使用了。哎呀，还是自己太懒，学的太慢，也特想自己快速的学东西，但是欲速则不达，有些东西还是要脚踏实地的去做才可以。 代码放在这里一份吧，留作参考coding仓库项目 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150# -*- coding: UTF-8 -*-from bs4 import BeautifulSoupfrom urllib import requestfrom urllib import parseimport jsonimport easyguiimport chardetimport re&quot;&quot;&quot;Request_URL = &apos;http://1.1.1.1:801/eportal/?c=ACSetting&amp;a=Login&amp;protocol=http:&amp;hostname=1.1.1.1&amp;iTermType=1&amp;wlanuserip=10.133.173.186&amp;wlanacip=10.10.9.200&amp;mac=00-00-00-00-00-00&amp;ip=10.133.173.186&amp;enAdvert=0&amp;queryACIP=0&amp;loginMethod=1&apos;Request_URL = &apos;http://1.1.1.1:801/eportal/?c=ACSetting&amp;a=Login&amp;protocol=http:&amp;hostname=1.1.1.1&amp;iTermType=1&amp;wlanuserip=&apos;+dongtai_ip()+&apos;&amp;wlanacip=10.10.9.200&amp;mac=00-00-00-00-00-00&amp;ip=10.133.173.186&amp;enAdvert=0&amp;queryACIP=0&amp;loginMethod=1&apos;&quot;&quot;&quot;def yulu (): yulu = &quot;http://word.rainss.cn/api_system.php?type=txt&quot; response = request.urlopen(yulu) html = response.read().decode(&apos;utf-8&apos;) #print(str(html))def dongtai_ip (): url = &apos;http://1.1.1.1/&apos; response3 = request.urlopen(url) html = response3.read().decode(&apos;gb2312&apos;) soup = BeautifulSoup(html, &apos;lxml&apos;) # 正则表达式寻找字符 jieguo = re.findall(&quot;v46m=0;v4ip=&apos;(.*)&apos;;v6ip=&apos;::&quot;, html) jieguo2 = re.findall(&quot;m46=0;v46ip=&apos;(.*)&apos;&quot;, html) #print(html) # print(str(jieguo2)) if jieguo2: print(jieguo2[0]) return jieguo2[0] else: print(jieguo[0]) return jieguo[0] # print(str(jieguo)) # 用beautiful soup 测试 #print(soup.prettify()) #print(soup.title.string)def post_denglu(): msg = &quot;请输入运营商，账号，密码(此窗口只会出现一次**版本号1.0)&quot; title = &quot;校园网一键登录-阿正原创&quot; user_info = [] user_info = easygui.multpasswordbox(msg, title, (&quot;运营商&quot;, &quot;账号&quot;, &quot;密码&quot;)) #print(user_info) #print(user_info[0]) #对应上图的Request URL test_url = &apos;http://1.1.1.1/&apos; #创建Form_Data字典，存储上图的Form Data Form_Data = &#123;&#125; Request_URL = &apos;http://1.1.1.1:801/eportal/?c=ACSetting&amp;a=Login&amp;protocol=http:&amp;hostname=1.1.1.1&amp;iTermType=1&amp;wlanuserip=&apos; + dongtai_ip() + &apos;&amp;wlanacip=10.10.9.200&amp;mac=00-00-00-00-00-00&amp;ip=10.133.173.186&amp;enAdvert=0&amp;queryACIP=0&amp;loginMethod=1&apos; fuhao = &quot;,0,&quot; zhanghao = user_info[1] yunyingshang = &quot;@cmcc&quot; Form_Data[&apos;DDDDD&apos;] = zhanghao+yunyingshang Form_Data[&apos;upass&apos;] = user_info[2] Form_Data[&apos;R1&apos;] = &apos;0&apos; Form_Data[&apos;R2&apos;] = &apos;0&apos; Form_Data[&apos;R3&apos;] = &apos;0&apos; Form_Data[&apos;R6&apos;] = &apos;0&apos; Form_Data[&apos;para&apos;] = &apos;00&apos; Form_Data[&apos;0MKKey&apos;] = &quot;123456&quot; #使用urlencode方法转换标准格式 data = parse.urlencode(Form_Data).encode(&apos;utf-8&apos;) #传递Request对象和转换完格式的数 response = request.urlopen(Request_URL,data) response2 = request.urlopen(test_url) #print(response.getcode()) # 判断网页的编码 bianma = chardet.detect(response2.read()) #print(bianma) bianma = bianma.get(&quot;encoding&quot;,&quot;bianma&quot;) # print(bianma) #读取信息并解码 html = response.read().decode(bianma) #print(html) soup = BeautifulSoup(html,&apos;lxml&apos;) # print(soup.prettify()) # print(soup.title.string) if soup.title.string == &quot;认证成功页&quot;: yulu = &quot;http://word.rainss.cn/api_system.php?type=txt&quot; response4 = request.urlopen(yulu) yulu_txt = response4.read().decode(&apos;utf-8&apos;) # print(str(yulu_txt)) easygui.buttonbox(&quot;登录成功您的动态IP为：&quot;+dongtai_ip()+&quot;\\n&quot;+yulu_txt,image=&quot;success.gif&quot;,choices=(&quot;无敌&quot;,&quot;寂寞&quot;)) # print(&quot;登录成功&quot;) f = open(&quot;zhanghao.txt&quot;, &quot;w&quot;) for i in user_info: json_i = json.dumps(i) f.write(json_i+&quot;\\n&quot;) f.close() else: easygui.msgbox(&quot;登录失败&quot;) ##UI设计def gogogo(): # 利用json读取数据 jiance_result = [] with open(&quot;zhanghao.txt&quot;, &quot;r&quot;) as f: jiance_jieguo = f.read().split(&apos;\\n&apos;)[:-1] for x in jiance_jieguo: json_x = json.loads(x) jiance_result.append(json_x) # print(jiance_result) #print(jiance_result[1]) f.close() if jiance_result[1]==&apos;&apos;: post_denglu() else: test_url = &apos;http://1.1.1.1/&apos; # 创建Form_Data字典，存储上图的Form Data Form_Data = &#123;&#125; Request_URL = &apos;http://1.1.1.1:801/eportal/?c=ACSetting&amp;a=Login&amp;protocol=http:&amp;hostname=1.1.1.1&amp;iTermType=1&amp;wlanuserip=&apos; + dongtai_ip() + &apos;&amp;wlanacip=10.10.9.200&amp;mac=00-00-00-00-00-00&amp;ip=10.133.173.186&amp;enAdvert=0&amp;queryACIP=0&amp;loginMethod=1&apos; zhanghao = jiance_result[1] yunyingshang = &quot;@cmcc&quot; Form_Data[&apos;DDDDD&apos;] = zhanghao + yunyingshang Form_Data[&apos;upass&apos;] = jiance_result[2] Form_Data[&apos;R1&apos;] = &apos;0&apos; Form_Data[&apos;R2&apos;] = &apos;0&apos; Form_Data[&apos;R3&apos;] = &apos;0&apos; Form_Data[&apos;R6&apos;] = &apos;0&apos; Form_Data[&apos;para&apos;] = &apos;00&apos; Form_Data[&apos;0MKKey&apos;] = &quot;123456&quot; # 使用urlencode方法转换标准格式 data = parse.urlencode(Form_Data).encode(&apos;utf-8&apos;) # 传递Request对象和转换完格式的数 response = request.urlopen(Request_URL, data) response2 = request.urlopen(test_url) #print(response.getcode()) if response.getcode() == 200: #print(&quot;登录成功&quot;) yulu = &quot;http://word.rainss.cn/api_system.php?type=txt&quot; response4 = request.urlopen(yulu) yulu_txt = response4.read().decode(&apos;utf-8&apos;) # print(str(yulu_txt)) easygui.buttonbox(&quot;登录成功您的动态IP为：&quot;+dongtai_ip()+&quot;\\n随机语录：\\n&quot;+yulu_txt,image=&quot;success.gif&quot;,choices=(&quot;666&quot;,&quot;666&quot;)) # 判断网页的编码 &quot;&quot;&quot; bianma = chardet.detect(response2.read()) print(bianma) bianma = bianma.get(&quot;encoding&quot;, &quot;bianma&quot;) print(bianma) # 读取信息并解码 html = response.read().decode(bianma) print(html) soup = BeautifulSoup(html, &apos;lxml&apos;) print(soup.prettify()) print(soup.title.string) &quot;&quot;&quot;gogogo()#post_denglu()#dongtai_ip()#yulu() 感谢教程，以后也继续努力学习！！莫烦python廖雪峰老师","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"智能家居控制模拟套件","slug":"智能家居控制模拟套件","date":"2018-05-08T13:45:00.000Z","updated":"2018-06-18T02:50:12.000Z","comments":true,"path":"2018/05/08/智能家居控制模拟套件/","link":"","permalink":"http://yoursite.com/2018/05/08/智能家居控制模拟套件/","excerpt":"智能家居控制模拟套件 针对有编程基础的学生开发的一套蓝牙局域网控制模拟套件。版本号【1.0】下一版本将更新WiFi远程控制系统。郑州三松信息技术有限公司出品。 电路图如下： 1、可实现的功能：","text":"智能家居控制模拟套件 针对有编程基础的学生开发的一套蓝牙局域网控制模拟套件。版本号【1.0】下一版本将更新WiFi远程控制系统。郑州三松信息技术有限公司出品。 电路图如下： 1、可实现的功能： 1、手机APP蓝牙控制led。2、手机APP蓝牙控制舵机。3、手机APP蓝牙控制直流电机。4、蜂鸣器交互。 2、元件介绍： 元件 数量 教程 备注 arduino_uno主控板 1块 用于程序主控 舵机 1个 可实现固定角度转动 直流空心杯电机 1个 输入高低电平即可工作 蜂鸣器 1个 可实现声音试人机交互 LED灯 1个 用于模拟日光灯操作 3、手机APP介绍：【此版本为安卓版，目前ios版本正在开发中】 4、手机APP功能详解： APP采用简介明了的交互界面，模拟智能家居的局域网控制。 点按触发。 语音控制 语音反馈 蓝牙检索 一键连接 5、手机端使用图解： 1、首先打开APP界面如下： 等待语音服务启动完毕，即可进入下一步： 2、蓝牙设备配对： 打开手机蓝牙 单击界面上的搜索设备按钮 APP将自动搜索局域的蓝牙设备如下图： 找到HC06的蓝牙设备，单击即可配对，秘钥为“1234” 3、APP的使用： 配对成功之后就可以单击界面上的按钮进行局域网控制了，具体单片机接受端的代码见代码详解篇。 4、语音遥控的使用： 单击界面中央的麦克风按钮，即可进行语音识别。 5、语音识别口令：【本版本软件内置六款口令进行模拟实验，仅供参考。】| 语音关键字 | 对应蓝牙串口值 | 功能 | 备注 || ————- |:————-:| —–:|| 开灯 | 1 | 对应实现单片机端LED灯开启 | || 关灯 | 2 | 对应实现单片机端LED灯关闭 | || 开门 | 3 | 对应实现单片机端舵机动作 | || 关门 | 4 | 对应实现单片机段舵机动作 | || 开风扇 | 5 | 对应实现单片机端电机启动 | || 关风扇 | 6 | 对应实现单片机端电机关闭 | |备注：所有关键字，只需语音中包含即可。例如：“请开门”、“开开门”、“芝麻开门”等，均可以实现开门的功能。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081//******************//郑州三松信息技术有限公司//***********************////******************//智能家居系统模拟1.0//******************////arduino手册地址：http://www.ocrobot.com/doku.php?id=learning#include&lt;Servo.h&gt;#include &lt;SoftwareSerial.h&gt;SoftwareSerial mySerial(0, 1); // RX, TX，定义0端口是接收端，1端口是发射端Servo myservo; char val=&apos;/&apos;;int pos=0;int Bee=2;//定义蜂鸣器对应单片机端口为2int LED=3; //定义led对应单片机端口为3int FAN=4; //定义风扇对应单片机端口为4int DUOJI=5;//定义开门舵机对应单片机端口为5void setup() //开机运行的程序代码&#123; pinMode(2,OUTPUT); //设置2号IO口为输出模式 pinMode(3,OUTPUT); //设置3号IO口为输出模式 pinMode(4,OUTPUT); //设置4号IO口为输出模式 digitalWrite(2,HIGH);//设置2号IO口为初始高电平状态 digitalWrite(4,LOW);//设置4号IO口为初始低电平状态 Serial.begin(9600);//设置串口波特率为9600 myservo.attach(5);//设置舵机连接口为5号IO口&#125; void loop() // 循环执行的程序代码&#123; val=Serial.read(); //接收数据 switch (val)&#123; case &apos;1&apos;: ledopen(); break; case &apos;2&apos;: ledclose(); break; case &apos;3&apos;: dooropen(); break; case &apos;4&apos;: doorclose(); break; case &apos;5&apos;: fanopen(); break; case &apos;6&apos;: fanclose(); break; //以上数据对应手机APP控制代码 &#125;&#125;////////////////////////////////////////////void fanopen() // 定义开风扇函数&#123; bee(); digitalWrite(4,HIGH); &#125;void fanclose() // 定义关风扇函数&#123; bee(); digitalWrite(4,LOW); &#125;void dooropen() // 定义开门函数&#123; bee();for(pos = 0; pos &lt;= 180; pos += 1) // 此处依靠for循环来实现舵机从0度旋转到180度的控制。 &#123; myservo.write(pos); delay(15); &#125; &#125;void doorclose() //定义关门函数&#123; bee(); for(pos = 180; pos&gt;=0; pos-=1) // 此处依靠for循环来实现舵机从180度旋转到0度的控制。 &#123; myservo.write(pos); delay(15); &#125; &#125;void ledopen() // 定义LED开启函数&#123; bee(); digitalWrite(3,HIGH); &#125; void ledclose() //定义LED关闭函数 &#123; bee(); digitalWrite(3,LOW); &#125; void bee() //定义蜂鸣器函数 &#123; tone(2,500,500); delay(200); tone(2,800,500); &#125;","categories":[],"tags":[{"name":"智能家居","slug":"智能家居","permalink":"http://yoursite.com/tags/智能家居/"}]},{"title":"python嵌入式开发","slug":"python嵌入式开发","date":"2018-02-28T14:53:00.000Z","updated":"2019-02-17T12:28:41.471Z","comments":true,"path":"2018/02/28/python嵌入式开发/","link":"","permalink":"http://yoursite.com/2018/02/28/python嵌入式开发/","excerpt":"","text":"现在是凌晨6：00，从下午我刚知道microPython，到现在我做成第一个硬件作品–mqtt协议远程控制LED灯。感觉这才是充实的感觉，心里舒服，当我看到python的历程里有那么多的教程和资料，欣喜若狂，好想赶紧学一些东西，做出更好玩，更有趣的东西。 第一个硬件的制作。 One net平台服务器端截图。 创作流程–思维导图 测试代码备份（一） 上电自动连接wifi 1234567891011121314def do_connect(): import network sta_if = network.WLAN(network.STA_IF) ap_if = network.WLAN(network.AP_IF) if ap_if.active(): ap_if.active(False) if not sta_if.isconnected(): print(&apos;connecting to network...&apos;) sta_if.active(True) sta_if.connect(&apos;Msun3&apos;, &apos;13456789&apos;) #wifi的SSID和密码 while not sta_if.isconnected(): pass print(&apos;network config:&apos;, sta_if.ifconfig())do_connect() 代码备份（二）网络访问服务器 123456789101112131415161718192021222324252627282930313233343536373839404142434445from simple import MQTTClientfrom machine import Pinimport machineimport micropython#选择G4引脚g4 = Pin(2, Pin.OUT, value=0)# MQTT服务器地址域名为：183.230.40.39,不变SERVER = &quot;183.230.40.39&quot;#设备IDCLIENT_ID = &quot;25781333&quot;#随便起个名字TOPIC = &quot;python&quot;#产品IDusername=&apos;121252&apos;#产品APIKey:password=&apos;X6WkL=PlCydW6y6rQ71ZCAzkQmQ=&apos;state = 0def sub_cb(topic, msg): global state print((topic, msg)) if msg == b&quot;on&quot;: g4.value(1) state = 1 print(&quot;1&quot;) elif msg == b&quot;off&quot;: g4.value(0) state = 0 print(&quot;0&quot;) elif msg == b&quot;toggle&quot;: state = 1 - state g4.value(state)def main(server=SERVER): #端口号为：6002 c = MQTTClient(CLIENT_ID, server,6002,username,password) c.set_callback(sub_cb) c.connect() c.subscribe(TOPIC) print(&quot;Connected to %s, subscribed to %s topic&quot; % (server, TOPIC)) try: while 1: c.wait_msg() finally: c.disconnect() 网络初级调试代码（简单get） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import networkfrom machine import Pinimport socketimport urllibimport timedef led_state(): p2 = Pin(2, Pin.OUT) p2.value(0) time.sleep_ms(500) p2.value(1) time.sleep_ms(500) p2.value(0) time.sleep_ms(500) p2.value(1)def do_connect(): sta_if = network.WLAN(network.STA_IF) p2 = Pin(2, Pin.OUT) sta_if.active(False) if not sta_if.isconnected(): p2.low() print(&apos;connecting to network...&apos;) sta_if.active(True) sta_if.connect(&apos;Msun3&apos;, &apos;13456789&apos;) while not sta_if.isconnected(): pass if sta_if.isconnected(): print(&apos;connect success&apos;) p2.high() print(&apos;network config:&apos;, sta_if.ifconfig())def http_get(url): _, _, host, path = url.split(&apos;/&apos;, 3) addr = socket.getaddrinfo(host, 80)[0][-1] s = socket.socket() s.connect(addr) s.send(bytes(&apos;GET /%s HTTP/1.0\\r\\nHost: %s\\r\\n\\r\\n&apos; % (path, host), &apos;utf8&apos;)) while True: data = s.recv(50) if data: recive=str(data, &apos;utf8&apos;) #print(&apos;recive:&apos;,recive) print(str(data, &apos;utf8&apos;), end=&apos;&apos;) if(recive.find(&apos;begin&apos;)&gt;-1): led_state() else: break s.close()do_connect()http_get(&apos;http://back.waphx.com/guessbook/book_list.aspx?siteid=24233&amp;classid=49392&amp;page=1&amp;sid=D1BD2C713EF464690_3_23240_25313_23240-2-0-0-0-320&apos;) 代码已上传我的coding–码市仓库 生活，简简单单，不以物喜不以己悲。追逐梦想，不忘初心。–2018年2月28日-凌晨。","categories":[],"tags":[{"name":"micropython","slug":"micropython","permalink":"http://yoursite.com/tags/micropython/"}]},{"title":"opencv配置成功","slug":"opencv配置成功","date":"2018-02-26T13:11:00.000Z","updated":"2018-05-25T12:23:16.000Z","comments":true,"path":"2018/02/26/opencv配置成功/","link":"","permalink":"http://yoursite.com/2018/02/26/opencv配置成功/","excerpt":"opencv3.31+vs2015配置成功 话说，这是我半年前就想做的东西，经历过太多次失败，可能是自己脑子愚钝，哎，感慨涕零。科普一下：vs2015就不用介绍了吧。opencv是何物呢？ OpenCV 是一个基于BSD许可（开源）发行的跨平台计算机视觉库，可以运行在Linux、Windows、Android和Mac OS操作系统上。它轻量级而且高效——由一系列 C 函数和少量 C++ 类构成，同时提供了Python、Ruby、MATLAB等语言的接口，实现了图像处理和计算机视觉方面的很多通用算法。OpenCV用C++语言编写，它的主要接口也是C++语言，但是依然保留了大量的C语言接口。该库也有大量的Python、Java and MATLAB/OCTAVE（版本2.5）的接口。这些语言的API接口函数可以通过在线文档获得。如今也提供对于C#、Ch、Ruby的支持。 工作领域：1、人机互动2、物体识别3、图像分割4、人脸识别5、动作识别6、运动跟踪7、机器人8、运动分析9、机器视觉10、结构分析11、汽车安全驾驶 好的，记录一下自己遇到的坑。风萧萧兮易水寒，想想都后怕。。。。。。","text":"opencv3.31+vs2015配置成功 话说，这是我半年前就想做的东西，经历过太多次失败，可能是自己脑子愚钝，哎，感慨涕零。科普一下：vs2015就不用介绍了吧。opencv是何物呢？ OpenCV 是一个基于BSD许可（开源）发行的跨平台计算机视觉库，可以运行在Linux、Windows、Android和Mac OS操作系统上。它轻量级而且高效——由一系列 C 函数和少量 C++ 类构成，同时提供了Python、Ruby、MATLAB等语言的接口，实现了图像处理和计算机视觉方面的很多通用算法。OpenCV用C++语言编写，它的主要接口也是C++语言，但是依然保留了大量的C语言接口。该库也有大量的Python、Java and MATLAB/OCTAVE（版本2.5）的接口。这些语言的API接口函数可以通过在线文档获得。如今也提供对于C#、Ch、Ruby的支持。 工作领域：1、人机互动2、物体识别3、图像分割4、人脸识别5、动作识别6、运动跟踪7、机器人8、运动分析9、机器视觉10、结构分析11、汽车安全驾驶 好的，记录一下自己遇到的坑。风萧萧兮易水寒，想想都后怕。。。。。。 软件版本问题 大概在半年之前我看的这位大神的教程进行配置opencv和cv2010，http://blog.csdn.net/poem_qianmo/article/details/19809337哎，无奈，总结如下，opencv到今天2018年2月已经更新到3.31版本，更新了什么功能不再考究，暂且讨论最基本的安装问题。opencv不再支持x86格式，在其安装包里也找不到相关文件，而且其对应文件为vc14，这句话就是说，适用于vs2015.以我的概念就是说–现在的opencv最好安装在vs2015上面（或者更高版本），其他版本我没有测试。之前我在笔记本上装了vs2010，哎磕磕绊绊到放弃也没能装上这神奇的软件。最后就搁置了。现在老师又给了我一台笔记本，又鼓起勇气再尝试一把，熬了几个夜晚（网速太慢），下载vs2015用了一夜，安装2015用了一下午，调试用了好几个小时。最尴尬的问题就是我先测试的还是vs2010，现在想来，真是笨，结果还是失败了，然后卸载2010用了好久，而且卸载不完全，导致2015安装的时候出现bug两者发生了冲突。 环境配置问题 这套环境我配置了不少于5便，现在背都能背下来。。。目前我成功的配置教程如下–https://www.cnblogs.com/linshuhe/p/5764394.html配置环境一定要认真！包括：opencv环境变量配置，vs2010支持文件的配置，w32窗体运行程序的属性管理器的配置，链接器的配置等等。此教程是正确的，起码我成功了。 调试出错问题 我调试的时候并没有出现太多错误，唯一就是，无法打开.exe文件，（这个是怎么解决的我也迷糊了，忘记了），另一个就是报错说 10x00007FFEE17E3FB8 处(位于 opencv.exe 中)有未经处理的异常: Microsoft C++ 异常: cv::Exception，位于内存位置 0x000000856230F880 处。 这个问题是很好解决的，那就是图片位置放错了，有的教程说放在工程目录下，其实不然！需要放在和.cpp同一级的文件夹里才行。 真正成功运行opencv的截图！！！ 1234今天睡早一点，好几天都是4点才睡，快不行了，身体是革命的本钱！可是我好慌，懂得东西太少，基础不牢，不专一，哎。------2018年2月26日.随笔。下一篇博客更新python学习进度！","categories":[],"tags":[{"name":"opencv","slug":"opencv","permalink":"http://yoursite.com/tags/opencv/"}]},{"title":"微信小程序的第一次邂逅","slug":"微信小程序的第一次邂逅","date":"2017-11-19T14:13:00.000Z","updated":"2018-05-12T04:43:22.000Z","comments":true,"path":"2017/11/19/微信小程序的第一次邂逅/","link":"","permalink":"http://yoursite.com/2017/11/19/微信小程序的第一次邂逅/","excerpt":"微信小程序的第一次邂逅与资料总结 （这应该是2017年的博客，只是重新备份一下。）前一段儿说要学习H5和微信小程序，说干就干，学了三天，每天两小时，照着课程一步一步来，突然找到了当年学习易语言的激情，和学习iapp时的乐趣，最喜欢学某个新的知识能够流畅的走下去的感觉（起码不要让我遇到太难的瓶颈），这样我也好坚持下去，毕竟我是一个很容易半途而废的人。 微信小程序官方文档—官方教程","text":"微信小程序的第一次邂逅与资料总结 （这应该是2017年的博客，只是重新备份一下。）前一段儿说要学习H5和微信小程序，说干就干，学了三天，每天两小时，照着课程一步一步来，突然找到了当年学习易语言的激情，和学习iapp时的乐趣，最喜欢学某个新的知识能够流畅的走下去的感觉（起码不要让我遇到太难的瓶颈），这样我也好坚持下去，毕竟我是一个很容易半途而废的人。 微信小程序官方文档—官方教程 知识总结备份于有道云笔记。我的云笔记 .js可暂且理解为一个获取数据和提供数据的地方 .wxml为显示数据和内容以及布局的地方 .wxss为对wxml进行布局设计的地方，包括排版，字体，颜色，背景等等。。。 item比如在list中，它代表list的每一项，大概是指，外部想的字文件。而且这是支持修改的比如利用 12345678&lt;view wx:for=&quot;&#123;&#123;list&#125;&#125;&quot;&gt; &#123;&#123;item.name&#125;&#125;--&#123;&#123;item.address&#125;&#125;&lt;/view&gt;可以修改为&lt;view wx:for=&quot;&#123;&#123;list&#125;&#125;&quot; wx:for-item=&quot;a&quot;&gt; &#123;&#123;a.name&#125;&#125;--&#123;&#123;a.address&#125;&#125;&lt;/view&gt; 判断语法js文件12345678910var app = getApp();这是是在调用事件必须的设置Page(&#123; data:&#123; msg:&quot;nihsao&quot;, time:&quot;20180215&quot;, name:app.globalData.name， 此处为调用调用小程序的系统事件 condition:100这里和下面的wxml文件对应，进行判断处理 &#125;, 其中app.ls文件为 1234globalData: &#123; userInfo: null, name:&quot;enen&quot;这里是上面name:app.globalData.name，调用的东西&#125; wxml文件12345678&lt;view class=&quot;msg&quot;&gt; &#123;&#123;msg&#125;&#125;&lt;/view&gt;&lt;view&gt;&#123;&#123;time&#125;&#125;--&#123;&#123;name&#125;&#125;&lt;/view&gt;判断语法&lt;view wx:if=&quot;&#123;&#123;condition&gt;90&#125;&#125;&quot;&gt; 90 &lt;/view&gt; 循环语法js文件 123456789Page(&#123; data:&#123; list[ &#123;name:&quot;tc01&quot;,address:&quot;eneneenen&quot;&#125;, &#123;name:&quot;tc02&quot;,address:&quot;zhengzhou&quot;&#125;, 里面包含列表的内容，json文件 ],此处因为是list所以用[]数组形式 wxml文件123456&lt;view wx:for=&quot;&#123;&#123;list&#125;&#125;&quot;&gt;for 代表操作和if类似， &#123;&#123;item.name&#125;&#125;--&#123;&#123;item.address&#125;&#125; 对应上面的list中的json文件&lt;/view&gt; 8天学会微信小程序第4课汇总 听了这一节的课，感觉有了茅塞顿开的感觉，因为讲到了很多实质性的东西。代码就不做备份了，以后直接传到Github里。 相对来说还是有进展的，同时也对H5有了一些概念（毕竟以前只是不求甚解罢了）。除夕夜快乐。","categories":[],"tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"http://yoursite.com/tags/微信小程序/"}]}]}